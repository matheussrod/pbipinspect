{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pbipinspect","text":"<p>Parse, validate and document your Power BI Project</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pbipinspect\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>This library transforms your Power BI project into a structured and validated state. It provides a set of tools to analyze, validate, and document your project.</p> <p>First, you need to create an inspect object. The <code>create_inspect</code> function takes a path to your project and returns a <code>PbipInspect</code> object. You can also instantiate the object directly using the PbipInspect class, but using <code>create_inspect</code> is recommended.</p> <pre><code>&gt;&gt;&gt; from pbipinspect import create_inspect\n&gt;&gt;&gt; inspect = create_inspect('your-project.pbip')\n</code></pre> <p>Inspect parse you Power BI Project and gives you the ability to validate and document it. ou can view the model generated from your project by accessing the <code>pbip.model</code> attribute. <pre><code>&gt;&gt;&gt; print(inspect.pbip.model)\n{'model': {\n    'tables': [{\n        'name': 'table',\n        'lineageTag': 'id',\n        'columns': [{...}],\n        'measures': [{...}],\n        'partitions': [{...}],\n        'isHidden': False,\n        'annotations': [{...}]\n    }],\n    'relationships': [{...}],\n    'expressions': [{...}]\n}}\n</code></pre></p>"},{"location":"#expectations","title":"Expectations","text":"<p>Now, it's possible to validate your project. pbipinspect already comes with some expects that you can use to validate your project.</p> <pre><code>&gt;&gt;&gt; from pbipinspect.expectations import *\n&gt;&gt;&gt; inspect.expectations(steps=[\n...     expect_col_starts_with(col_type='dateTime', pattern='dt_', state='Info'),\n...     expect_measure_starts_with(pattern='m_'),\n...     expect_table_starts_with(pattern='t_'),\n...     expect_table_name_no_spaces(),\n...     expect_cols_in_relationship_has_same_type(),\n...     expect_dax_lines_length(max_length=60),\n...     expect_m_lines_length(max_length=60),\n...     expect_measures_in_specific_table('_measures'),\n...     expect_no_calculated_columns(state='Error'),\n...     expect_all_relationships_active()\n&gt;&gt;&gt; ])\n&gt;&gt;&gt; inspect.run_expectations()\n&gt;&gt;&gt; print(inspect.expects)\n[{'expect': 'expect_col_starts_with',\n   'state': 'Warning',\n   'message': \"Column 'Column1' in table 'Table1' must start with 'dt_'\"},\n {'expect': 'expect_no_calculated_columns',\n  'state': 'Error',\n  'message': \"Table 'Table1' has calculated columns: 'Column2' and 'Column3'\"}\n]\n</code></pre>"},{"location":"#building-documentation","title":"Building documentation","text":"<p>Additionally, you can generate documentation for your project using the <code>build_report</code> method. <pre><code>&gt;&gt;&gt; report = inspect.build_report()\n</code></pre></p> <p>By default, this approach will create a report using the default template. However, you can change the template and the variables by specifying the <code>report_template</code> and <code>render</code> parameters.</p> <p>You can also use the <code>add_metadata</code> method to include metadata in your report. This metadata will be displayed at the top of the report in the \"Overview\" section. Therefore, metadata should be used to provide information about your project, such as its name, description, author, etc.</p> <pre><code>&gt;&gt;&gt; inspect.add_metadata({\n...     'name': 'Project name',\n...     'description': 'Project description',\n...     'author': 'Author'\n... })\n&gt;&gt;&gt; report = inspect.build_report()\n</code></pre>"},{"location":"#tables-columns-and-measures-descriptions","title":"Tables, columns and measures descriptions","text":"<p>pbipinspect introduces a method for generating descriptions for tables, columns, and measures. In your Power BI project, you can add a comment in the source code of a table following this pattern:</p> <pre><code>/* @doc \nTable description\n\n@col column1:\ncolumn1 description\n\n@col column2:\ncolumn2 description\n*/\nlet\n    Source = Table.FromRecords({\n        [column1 = 1, column2 = 2]\n    }),\n    #\"Changed Type\" = Table.TransformColumnTypes(\n      Source,\n      {{\"col1\", number}, {\"col2\", number}}\n    )\nin\n    #\"Changed Type\"\n</code></pre> <p>The same pattern can be used for measures: <pre><code>/* @doc \nMeasure description\n*/\nvar = 1\nreturn var + 1\n</code></pre></p> <p>These descriptions are added to the \"description\" field of each corresponding property in the parsed model.</p>"},{"location":"#the-model","title":"The model","text":"<p>The <code>pbip.model</code> field of the <code>PbipInspect</code> object contains the parsed model of your Power BI Project. Currently, the model contains the following fields:</p> <pre><code>{\n  \"type\": \"object\",\n  \"properties\": {\n    \"model\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"tables\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"object\",\n            \"properties\": {\n              \"name\": { \"type\": \"string\" },\n              \"lineageTag\": { \"type\": \"string\" },\n              \"isHidden\": { \"type\": \"boolean\" },\n              \"isPrivate\": { \"type\": \"boolean\" },\n              \"columns\": {\n                \"type\": \"array\",\n                \"items\": {\n                  \"type\": \"object\",\n                  \"properties\": {\n                    \"name\": { \"type\": \"string\" },\n                    \"expression\": { \"type\": \"string\" },\n                    \"isHidden\": { \"type\": \"boolean\" },\n                    \"isNameInferred\": { \"type\": \"boolean\" },\n                    \"dataType\": { \"type\": \"string\" },\n                    \"lineageTag\": { \"type\": \"string\" },\n                    \"summarizeBy\": { \"type\": \"string\" },\n                    \"sourceColumn\": { \"type\": \"string\" },\n                    \"annotations\": {\n                      \"type\": \"array\",\n                      \"items\": {\n                        \"type\": \"object\",\n                        \"properties\": {\n                          \"name\": { \"type\": \"string\" },\n                          \"value\": { \"type\": \"string\" }\n                        }\n                      }\n                    },\n                    \"calculated\": { \"type\": \"boolean\" },\n                    \"description\": { \"type\": \"string\" }\n                  }\n                }\n              },\n              \"measures\": {\n                \"type\": \"array\",\n                \"items\": {\n                  \"type\": \"object\",\n                  \"properties\": {\n                    \"name\": { \"type\": \"string\" },\n                    \"lineageTag\": { \"type\": \"string\" },\n                    \"annotations\": {\n                      \"type\": \"array\",\n                      \"items\": {\n                        \"type\": \"object\",\n                        \"properties\": {\n                          \"name\": { \"type\": \"string\" },\n                          \"value\": { \"type\": \"string\" }\n                        }\n                      }\n                    },\n                    \"displayFolder\": { \"type\": \"string\" },\n                    \"expression\": { \"type\": \"string\" },\n                    \"formatString\": { \"type\": \"string\" },\n                    \"description\": { \"type\": \"string\" },\n                    \"references\": {\n                      \"type\": \"array\",\n                      \"items\": {\n                        \"type\": \"object\",\n                        \"properties\": {\n                          \"type\": { \"type\": \"string\" },\n                          \"name\": { \"type\": \"string\" },\n                          \"column\": { \"type\": \"string\" }\n                        }\n                      }\n                    }\n                  }\n                }\n              },\n              \"partitions\": {\n                \"type\": \"array\",\n                \"items\": {\n                  \"type\": \"object\",\n                  \"properties\": {\n                    \"name\": { \"type\": \"string\" },\n                    \"type\": { \"type\": \"string\" },\n                    \"mode\": { \"type\": \"string\" },\n                    \"raw_expression\": { \"type\": \"string\" },\n                    \"expression\": { \"type\": \"string\" },\n                    \"description\": { \"type\": \"string\" }\n                  }\n                }\n              }\n            }\n          }\n        },\n        \"relationships\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"object\",\n            \"properties\": {\n              \"name\": { \"type\": \"string\" },\n              \"fromTable\": { \"type\": \"string\" },\n              \"fromColumn\": { \"type\": \"string\" },\n              \"toTable\": { \"type\": \"string\" },\n              \"toColumn\": { \"type\": \"string\" },\n              \"crossFilteringBehavior\": { \"type\": \"string\" },\n              \"filteringSymbol\": { \"type\": \"string\" },\n              \"fromCardinalitySymbol\": { \"type\": \"string\" },\n              \"toCardinalitySymbol\": { \"type\": \"string\" },\n              \"isActive\": { \"type\": \"boolean\" }\n            }\n          }\n        },\n        \"expressions\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"object\",\n            \"properties\": {\n              \"name\": { \"type\": \"string\" },\n              \"lineageTag\": { \"type\": \"string\" },\n              \"type\": { \"type\": \"string\" },\n              \"expression\": { \"type\": \"string\" },\n              \"description\": { \"type\": \"string\" }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre>"},{"location":"#getting-help","title":"Getting help","text":"<p>If you encounter a clear bug, please file an issue with a minimal reproducible example on GitHub.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#010-2024-12-13","title":"[0.1.0] - 2024-12-13","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Expectations to validate Power BI project</li> <li>tmsl and tmdl parser</li> <li><code>Pbip</code> and <code>PbipInspect</code> class</li> <li><code>create_inspect</code> function to create a <code>PbipInspect</code></li> </ul>"},{"location":"license/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2024 Matheus S. Rodrigues</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"reference/expectations/","title":"expectations","text":"<p>Functions:</p> <ul> <li> <code>expect_all_relationships_active</code>             \u2013              <p>Returns a function that checks if all relationships in a Pbip object are active.</p> </li> <li> <code>expect_col_starts_with</code>             \u2013              <p>Returns a function that checks if columns in a Pbip object start</p> </li> <li> <code>expect_cols_in_relationship_has_same_type</code>             \u2013              <p>Returns a function that checks if columns in relationships of a Pbip object have the same type.</p> </li> <li> <code>expect_dax_lines_length</code>             \u2013              <p>Returns a function that checks if DAX measures in a Pbip object do not exceed the specified maximum length.</p> </li> <li> <code>expect_m_lines_length</code>             \u2013              <p>Returns a function that checks if M language expressions in the partitions</p> </li> <li> <code>expect_measure_starts_with</code>             \u2013              <p>Returns a function that checks if measures in a Pbip object start</p> </li> <li> <code>expect_measures_in_specific_table</code>             \u2013              <p>Returns a function that checks if measures in a Pbip object are in a specific table.</p> </li> <li> <code>expect_no_calculated_columns</code>             \u2013              <p>Returns a function that checks if calculated columns are not present in any table of a Pbip object.</p> </li> <li> <code>expect_no_calculated_tables</code>             \u2013              <p>Returns a function that checks if calculated tables are not present in a Pbip object.</p> </li> <li> <code>expect_table_name_no_spaces</code>             \u2013              <p>Returns a function that checks if table names in a Pbip object do not contain spaces.</p> </li> <li> <code>expect_table_starts_with</code>             \u2013              <p>Returns a function that checks if table names in a Pbip object start</p> </li> </ul>"},{"location":"reference/expectations/#pbipinspect.expectations.expect_all_relationships_active","title":"<code>expect_all_relationships_active(state: ExpectState = 'Warning') -&gt; Callable</code>","text":"<p>Returns a function that checks if all relationships in a Pbip object are active.</p> <p>Parameters:</p> <ul> <li> <code>state</code>               (<code>ExpectState</code>, default:                   <code>'Warning'</code> )           \u2013            <p>The state of the expectation, defaults to 'Warning'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>A function that checks if all relationships in a Pbip object are active.</p> </li> </ul> Source code in <code>pbipinspect/expectations.py</code> <pre><code>def expect_all_relationships_active(\n    state: ExpectState = 'Warning'\n) -&gt; Callable:\n    \"\"\"\n    Returns a function that checks if all relationships in a Pbip object are active.\n\n    Parameters\n    ----------\n    state : ExpectState, optional\n        The state of the expectation, defaults to 'Warning'.\n\n    Returns\n    -------\n    Callable\n        A function that checks if all relationships in a Pbip object are active.\n    \"\"\"\n\n    def function(pbip: Pbip) -&gt; list[ExpectMessage]:\n        relationships = pbip.relationships\n        if not relationships:\n            return []\n        checks = []\n        for relationship in relationships:\n            from_table = relationship['fromTable']\n            to_table = relationship['toTable']\n            from_column = relationship['fromColumn']\n            to_column = relationship['toColumn']\n            if not relationship['isActive']:\n                checks.append({\n                    'expect': 'expect_all_relationships_active',\n                    'state': state,\n                    'message': (f\"Relationship between '{from_table}.{from_column}' and '{to_table}.{to_column}' must be active.\"),\n                })\n        return checks\n    return function\n</code></pre>"},{"location":"reference/expectations/#pbipinspect.expectations.expect_col_starts_with","title":"<code>expect_col_starts_with(pattern: str, col_type: list[ColTypes] | ColTypes | None, state: ExpectState = 'Warning') -&gt; Callable</code>","text":"<p>Returns a function that checks if columns in a Pbip object start with the specified pattern and have a supported data type.</p> <p>Parameters:</p> <ul> <li> <code>pattern</code>               (<code>str</code>)           \u2013            <p>The pattern to match against the column name.</p> </li> <li> <code>col_type</code>               (<code>list[ColTypes] | ColTypes | None</code>)           \u2013            <p>The data type(s) to check for.</p> </li> <li> <code>state</code>               (<code>ExpectState</code>, default:                   <code>'Warning'</code> )           \u2013            <p>The state of the expectation, defaults to 'Warning'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>A function that checks if columns in a Pbip object start with the specified pattern and have a supported data type.</p> </li> </ul> Source code in <code>pbipinspect/expectations.py</code> <pre><code>def expect_col_starts_with(\n    pattern: str, \n    col_type: list[ColTypes] | ColTypes | None,\n    state: ExpectState = 'Warning'\n) -&gt; Callable:\n    \"\"\"\n    Returns a function that checks if columns in a Pbip object start\n    with the specified pattern and have a supported data type.\n\n    Parameters\n    ----------\n    pattern : str\n        The pattern to match against the column name.\n    col_type : list[ColTypes] | ColTypes | None\n        The data type(s) to check for.\n    state : ExpectState, optional\n        The state of the expectation, defaults to 'Warning'.\n\n    Returns\n    -------\n    Callable\n        A function that checks if columns in a Pbip object start\n        with the specified pattern and have a supported data type.\n    \"\"\"\n    not_supported = ['binary', 'list', 'record', 'time', 'percentage', 'duration'] \n\n    if col_type and not isinstance(col_type, list):\n        col_type = [col_type]\n\n    if col_type:\n        for col in col_type:\n            if col in not_supported:\n                Warning(f\"Col type '{col}' is not supported. I'll ignore this type.\")\n        col_type = [x for x in col_type if x not in not_supported]\n\n    def function(pbip: Pbip) -&gt; list[ExpectMessage]:\n        \"\"\"\n        Checks if columns in each table of the Pbip object start with a specified pattern\n        and match any of the specified data types.\n\n        Args:\n            pbip (Pbip): The Pbip object containing tables and columns to check.\n\n        Returns:\n            list[ExpectMessage]: A list of messages detailing any columns that do not meet the criteria.\n        \"\"\"\n        tables = pbip.tables\n        checks = []\n        for table in tables:\n            table_name = table['name']\n            cols = pbip.get_table_field(table_name, 'columns')\n            if not cols:\n                continue\n            for col in cols:\n                col_name = col['name']\n                check_type = col_type is None or col['dataType'] in col_type\n                if check_type and not col_name.startswith(pattern):\n                    checks.append({\n                        'expect': 'expect_col_starts_with',\n                        'state': state,\n                        'message': f\"Column '{col_name}' in table '{table_name}' must start with '{pattern}'\"\n                    })\n        return checks\n\n    return function\n</code></pre>"},{"location":"reference/expectations/#pbipinspect.expectations.expect_cols_in_relationship_has_same_type","title":"<code>expect_cols_in_relationship_has_same_type(state: ExpectState = 'Warning') -&gt; Callable</code>","text":"<p>Returns a function that checks if columns in relationships of a Pbip object have the same type.</p> <p>Parameters:</p> <ul> <li> <code>state</code>               (<code>ExpectState</code>, default:                   <code>'Warning'</code> )           \u2013            <p>The state of the expectation, defaults to 'Warning'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>A function that checks if columns in relationships of a Pbip object have the same type.</p> </li> </ul> Source code in <code>pbipinspect/expectations.py</code> <pre><code>def expect_cols_in_relationship_has_same_type(\n    state: ExpectState = 'Warning'\n) -&gt; Callable:\n    \"\"\"\n    Returns a function that checks if columns in relationships of a Pbip object have the same type.\n\n    Parameters\n    ----------\n    state : ExpectState, optional\n        The state of the expectation, defaults to 'Warning'.\n\n    Returns\n    -------\n    Callable\n        A function that checks if columns in relationships of a Pbip object have the same type.\n    \"\"\"\n    def function(pbip: Pbip) -&gt; list[ExpectMessage]:\n        checks = []\n        relationships = pbip.relationships\n        for relationship in relationships:\n            from_column = relationship['fromColumn']\n            from_table = relationship['fromTable']\n            to_column = relationship['toColumn']\n            to_table = relationship['toTable']\n\n            from_table_column = pbip.get_table_column(from_table, from_column)\n            to_table_column = pbip.get_table_column(to_table, to_column)\n\n            if from_table_column and to_table_column:\n                from_column_type = from_table_column['dataType']\n                to_column_type = to_table_column['dataType']\n\n                if from_column_type != to_column_type:\n                    checks.append({\n                        'expect': 'expect_cols_in_relationship_has_same_type',\n                        'state': state,\n                        'message': dedent(f\"\"\"\n                            Column '{from_column}' in table '{from_table}' and '{to_column}' in table '{to_table}' must have the same type.\n                            But I found '{from_column}' with '{from_column_type}' type and '{to_column}' with '{to_column_type}' type.\n                        \"\"\").strip()\n                    })\n        return checks\n    return function\n</code></pre>"},{"location":"reference/expectations/#pbipinspect.expectations.expect_dax_lines_length","title":"<code>expect_dax_lines_length(max_length: int, state: ExpectState = 'Warning') -&gt; Callable</code>","text":"<p>Returns a function that checks if DAX measures in a Pbip object do not exceed the specified maximum length.</p> <p>Parameters:</p> <ul> <li> <code>max_length</code>               (<code>int</code>)           \u2013            <p>The maximum length of a DAX measure.</p> </li> <li> <code>state</code>               (<code>ExpectState</code>, default:                   <code>'Warning'</code> )           \u2013            <p>The state of the expectation, defaults to 'Warning'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>A function that checks if DAX measures in a Pbip object do not exceed the specified maximum length.</p> </li> </ul> Source code in <code>pbipinspect/expectations.py</code> <pre><code>def expect_dax_lines_length(\n    max_length: int,\n    state: ExpectState = 'Warning'\n) -&gt; Callable:\n    \"\"\"\n    Returns a function that checks if DAX measures in a Pbip object do not exceed the specified maximum length.\n\n    Parameters\n    ----------\n    max_length : int\n        The maximum length of a DAX measure.\n    state : ExpectState, optional\n        The state of the expectation, defaults to 'Warning'.\n\n    Returns\n    -------\n    Callable\n        A function that checks if DAX measures in a Pbip object do not exceed the specified maximum length.\n    \"\"\"\n    def function(pbip: Pbip) -&gt; list[ExpectMessage]:\n        tables = pbip.tables\n        checks = []\n        for table in tables:\n            table_name = table['name']\n            measures = pbip.get_table_field(table_name, 'measures')\n            if not measures:\n                continue\n            for measure in measures:\n                measure_name = measure['name']\n                expression = measure['expression']\n                lines = check_lines_max_length(expression, max_length)\n                text = smart_join([x[0] for x in lines])\n                if any([x[1] for x in lines]):\n                    checks.append({\n                        'expect': 'expect_dax_lines_length',\n                        'state': state,\n                        'message': f\"Measure '{measure_name}' in table '{table_name}' has line(s) {text} longer than {max_length} characters\",\n                    })\n        return checks\n    return function\n</code></pre>"},{"location":"reference/expectations/#pbipinspect.expectations.expect_m_lines_length","title":"<code>expect_m_lines_length(max_length: int, state: ExpectState = 'Warning') -&gt; Callable</code>","text":"<p>Returns a function that checks if M language expressions in the partitions of tables within a Pbip object do not exceed the specified maximum length.</p> <p>Parameters:</p> <ul> <li> <code>max_length</code>               (<code>int</code>)           \u2013            <p>The maximum length of a line in an M language expression.</p> </li> <li> <code>state</code>               (<code>ExpectState</code>, default:                   <code>'Warning'</code> )           \u2013            <p>The state of the expectation, defaults to 'Warning'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>A function that checks if M language expressions in the partitions of tables within a Pbip object do not exceed the specified maximum length.</p> </li> </ul> Source code in <code>pbipinspect/expectations.py</code> <pre><code>def expect_m_lines_length(\n    max_length: int,\n    state: ExpectState = 'Warning'\n) -&gt; Callable:\n    \"\"\"\n    Returns a function that checks if M language expressions in the partitions\n    of tables within a Pbip object do not exceed the specified maximum length.\n\n    Parameters\n    ----------\n    max_length : int\n        The maximum length of a line in an M language expression.\n    state : ExpectState, optional\n        The state of the expectation, defaults to 'Warning'.\n\n    Returns\n    -------\n    Callable\n        A function that checks if M language expressions in the partitions\n        of tables within a Pbip object do not exceed the specified maximum length.\n    \"\"\"\n    def function(pbip: Pbip) -&gt; list[ExpectMessage]:\n        tables = pbip.tables\n        checks = []\n        for table in tables:\n            table_name = table['name']\n            partitions = pbip.get_table_field(table_name, 'partitions')\n            if not partitions:\n                continue\n            for partition in partitions:\n                expression = partition['expression']\n                lines = check_lines_max_length(expression, max_length)\n                text = text = smart_join([x[0] for x in lines])\n                if any([x[1] for x in lines]):\n                    checks.append({\n                        'expect': 'expect_m_lines_length',\n                        'state': state,\n                        'message': f\"Source code of table '{table_name}' has line(s) {text} longer than {max_length} characters\",\n                    })\n        return checks\n    return function\n</code></pre>"},{"location":"reference/expectations/#pbipinspect.expectations.expect_measure_starts_with","title":"<code>expect_measure_starts_with(pattern: str, state: ExpectState = 'Warning') -&gt; Callable</code>","text":"<p>Returns a function that checks if measures in a Pbip object start with the specified pattern.</p> <p>Parameters:</p> <ul> <li> <code>pattern</code>               (<code>str</code>)           \u2013            <p>The pattern to match against the measure name.</p> </li> <li> <code>state</code>               (<code>ExpectState</code>, default:                   <code>'Warning'</code> )           \u2013            <p>The state of the expectation, defaults to 'Warning'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>A function that checks if measures in a Pbip object start with the specified pattern.</p> </li> </ul> Source code in <code>pbipinspect/expectations.py</code> <pre><code>def expect_measure_starts_with(\n    pattern: str, \n    state: ExpectState = 'Warning'\n) -&gt; Callable:\n    \"\"\"\n    Returns a function that checks if measures in a Pbip object start\n    with the specified pattern.\n\n    Parameters\n    ----------\n    pattern : str\n        The pattern to match against the measure name.\n    state : ExpectState, optional\n        The state of the expectation, defaults to 'Warning'.\n\n    Returns\n    -------\n    Callable\n        A function that checks if measures in a Pbip object start\n        with the specified pattern.\n    \"\"\"\n\n    def function(pbip: Pbip) -&gt; list[ExpectMessage]:\n        tables = pbip.tables\n        checks = []\n        for table in tables:\n            table_name = table['name']\n            measures = pbip.get_table_field(table_name, 'measures')\n            if not measures:\n                continue\n            for measure in measures:\n                measure_name = measure['name']\n                if not measure_name.startswith(pattern):\n                    checks.append({\n                        'expect': 'expect_measure_starts_with',\n                        'state': state,\n                        'message': f\"Measure '{measure_name}' in table '{table_name}' must start with '{pattern}'\",\n                    })\n        return checks\n    return function\n</code></pre>"},{"location":"reference/expectations/#pbipinspect.expectations.expect_measures_in_specific_table","title":"<code>expect_measures_in_specific_table(table_name: str, state: ExpectState = 'Warning') -&gt; Callable</code>","text":"<p>Returns a function that checks if measures in a Pbip object are in a specific table.</p> <p>Parameters:</p> <ul> <li> <code>table_name</code>               (<code>str</code>)           \u2013            <p>The name of the table where measures should be.</p> </li> <li> <code>state</code>               (<code>ExpectState</code>, default:                   <code>'Warning'</code> )           \u2013            <p>The state of the expectation, defaults to 'Warning'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>A function that checks if measures in a Pbip object are in a specific table.</p> </li> </ul> Source code in <code>pbipinspect/expectations.py</code> <pre><code>def expect_measures_in_specific_table(\n    table_name: str,\n    state: ExpectState = 'Warning'\n) -&gt; Callable:\n    \"\"\"\n    Returns a function that checks if measures in a Pbip object are in a specific table.\n\n    Parameters\n    ----------\n    table_name : str\n        The name of the table where measures should be.\n    state : ExpectState, optional\n        The state of the expectation, defaults to 'Warning'.\n\n    Returns\n    -------\n    Callable\n        A function that checks if measures in a Pbip object are in a specific table.\n    \"\"\"\n    def function(pbip: Pbip) -&gt; list[ExpectMessage]:\n        tables = pbip.tables\n        checks = []\n        tables_with_measures = []\n        for table in tables:\n            measures = pbip.get_table_field(table['name'], 'measures')\n            if measures:\n                tables_with_measures.append(table['name'])\n        invalid_tables = [\n            table\n            for table in tables_with_measures\n            if table != table_name\n        ]\n        if invalid_tables:\n            checks.append({\n                'expect': 'expect_measures_in_specific_table',\n                'state': state,\n                'message': f\"Measures must be in table '{table_name}' but found in table(s) {smart_join(invalid_tables)}\",\n            })\n        return checks\n    return function\n</code></pre>"},{"location":"reference/expectations/#pbipinspect.expectations.expect_no_calculated_columns","title":"<code>expect_no_calculated_columns(state: ExpectState = 'Warning') -&gt; Callable</code>","text":"<p>Returns a function that checks if calculated columns are not present in any table of a Pbip object.</p> <p>Parameters:</p> <ul> <li> <code>state</code>               (<code>ExpectState</code>, default:                   <code>'Warning'</code> )           \u2013            <p>The state of the expectation, defaults to 'Warning'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>A function that checks if calculated columns are not present in any table of a Pbip object.</p> </li> </ul> Source code in <code>pbipinspect/expectations.py</code> <pre><code>def expect_no_calculated_columns(\n    state: ExpectState = 'Warning'\n) -&gt; Callable:\n    \"\"\"\n    Returns a function that checks if calculated columns are not present in any table of a Pbip object.\n\n    Parameters\n    ----------\n    state : ExpectState, optional\n        The state of the expectation, defaults to 'Warning'.\n\n    Returns\n    -------\n    Callable\n        A function that checks if calculated columns are not present in any table of a Pbip object.\n    \"\"\"\n    def function(pbip: Pbip) -&gt; list[ExpectMessage]:\n        tables = pbip.tables\n        checks = []\n        for table in tables:\n            columns = []\n            table_name = table['name']\n            table_columns = pbip.get_table_field(table_name, 'columns')\n            if table_columns is None:\n                continue\n            for column in table_columns:\n                if column['calculated']:\n                    columns.append(column['name'])\n            if columns:\n                checks.append({\n                    'expect': 'expect_no_calculated_columns',\n                    'state': state,\n                    'message': f\"Table '{table_name}' has calculated columns: {smart_join(columns)}\",\n                })\n        return checks\n    return function\n</code></pre>"},{"location":"reference/expectations/#pbipinspect.expectations.expect_no_calculated_tables","title":"<code>expect_no_calculated_tables(state: ExpectState = 'Warning') -&gt; Callable</code>","text":"<p>Returns a function that checks if calculated tables are not present in a Pbip object.</p> <p>Parameters:</p> <ul> <li> <code>state</code>               (<code>ExpectState</code>, default:                   <code>'Warning'</code> )           \u2013            <p>The state of the expectation, defaults to 'Warning'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>A function that checks if calculated tables are not present in a Pbip object.</p> </li> </ul> Source code in <code>pbipinspect/expectations.py</code> <pre><code>def expect_no_calculated_tables(\n    state: ExpectState = 'Warning'\n) -&gt; Callable:\n    \"\"\"\n    Returns a function that checks if calculated tables are not present in a Pbip object.\n\n    Parameters\n    ----------\n    state : ExpectState, optional\n        The state of the expectation, defaults to 'Warning'.\n\n    Returns\n    -------\n    Callable\n        A function that checks if calculated tables are not present in a Pbip object.\n    \"\"\"\n    def function(pbip: Pbip) -&gt; list[ExpectMessage]:\n        tables = pbip.tables\n        checks = []\n        for table in tables:\n            if table['partitions'][0]['type'] == 'calculated':\n                checks.append({\n                    'expect': 'expect_no_calculated_tables',\n                    'state': state,\n                    'message': f\"Table '{table['name']}' is calculated\",\n                })\n        return checks\n    return function\n</code></pre>"},{"location":"reference/expectations/#pbipinspect.expectations.expect_table_name_no_spaces","title":"<code>expect_table_name_no_spaces(state: ExpectState = 'Warning') -&gt; Callable</code>","text":"<p>Returns a function that checks if table names in a Pbip object do not contain spaces.</p> <p>Parameters:</p> <ul> <li> <code>state</code>               (<code>ExpectState</code>, default:                   <code>'Warning'</code> )           \u2013            <p>The state of the expectation, defaults to 'Warning'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>A function that checks if table names in a Pbip object do not contain spaces.</p> </li> </ul> Source code in <code>pbipinspect/expectations.py</code> <pre><code>def expect_table_name_no_spaces(\n    state: ExpectState = 'Warning'\n) -&gt; Callable:\n    \"\"\"\n    Returns a function that checks if table names in a Pbip object do not contain spaces.\n\n    Parameters\n    ----------\n    state : ExpectState, optional\n        The state of the expectation, defaults to 'Warning'.\n\n    Returns\n    -------\n    Callable\n        A function that checks if table names in a Pbip object do not contain spaces.\n    \"\"\"\n\n    def function(pbip: Pbip) -&gt; list[ExpectMessage]:\n        tables = pbip.tables\n        checks = []\n        for table in tables:\n            table_name = table['name']\n            if ' ' in table_name:\n                checks.append({\n                    'expect': 'expect_table_name_no_spaces',\n                    'state': state,\n                    'message': f\"Table '{table_name}' must not contain spaces\",\n                })\n        return checks\n    return function\n</code></pre>"},{"location":"reference/expectations/#pbipinspect.expectations.expect_table_starts_with","title":"<code>expect_table_starts_with(pattern: str, state: ExpectState = 'Warning') -&gt; Callable</code>","text":"<p>Returns a function that checks if table names in a Pbip object start with the specified pattern.</p> <p>Parameters:</p> <ul> <li> <code>pattern</code>               (<code>str</code>)           \u2013            <p>The pattern to match against the table name.</p> </li> <li> <code>state</code>               (<code>ExpectState</code>, default:                   <code>'Warning'</code> )           \u2013            <p>The state of the expectation, defaults to 'Warning'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>A function that checks if table names in a Pbip object start with the specified pattern.</p> </li> </ul> Source code in <code>pbipinspect/expectations.py</code> <pre><code>def expect_table_starts_with(\n    pattern: str, \n    state: ExpectState = 'Warning'\n) -&gt; Callable:\n    \"\"\"\n    Returns a function that checks if table names in a Pbip object start\n    with the specified pattern.\n\n    Parameters\n    ----------\n    pattern : str\n        The pattern to match against the table name.\n    state : ExpectState, optional\n        The state of the expectation, defaults to 'Warning'.\n\n    Returns\n    -------\n    Callable\n        A function that checks if table names in a Pbip object start\n        with the specified pattern.\n    \"\"\"\n    def function(pbip: Pbip) -&gt; list[ExpectMessage]:\n        tables = pbip.tables\n        checks = []\n        for table in tables:\n            table_name = table['name']\n            if not table_name.startswith(pattern):\n                checks.append({\n                    'expect': 'expect_table_starts_with',\n                    'state': state,\n                    'message': f\"Table '{table_name}' must start with '{pattern}'\",\n                })\n        return checks\n    return function\n</code></pre>"},{"location":"reference/inspect/","title":"inspect","text":"<p>Classes:</p> <ul> <li> <code>PbipInspect</code>           \u2013            <p>A class for inspecting .pbip files and their associated TMDL and TMSL models.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>create_inspect</code>             \u2013              <p>Create a PbipInspect object from a given path, which can be a .pbip file or a directory </p> </li> </ul>"},{"location":"reference/inspect/#pbipinspect.inspect.PbipInspect","title":"<code>PbipInspect(name: str | Path, semantic_folder: str | Path, report_folder: str | Path)</code>","text":"<p>A class for inspecting .pbip files and their associated TMDL and TMSL models.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | Path</code>)           \u2013            <p>The name of the .pbip file.</p> </li> <li> <code>semantic_folder</code>               (<code>str | Path</code>)           \u2013            <p>The path of the semantic model folder.</p> </li> <li> <code>report_folder</code>               (<code>str | Path</code>)           \u2013            <p>The path of the report folder.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>add_metadata</code>             \u2013              <p>Add metadata to the report.</p> </li> <li> <code>expectations</code>             \u2013              <p>Register a list of expectation functions to run against the model.</p> </li> <li> <code>parse_pbip</code>             \u2013              <p>Parse the PBIP model from the semantic folder.</p> </li> <li> <code>parse_relationships_to_mermaid</code>             \u2013              <p>Given a JSON content describing Power BI relationships,</p> </li> <li> <code>parse_tmdl</code>             \u2013              <p>Parse the TMDL model from the semantic folder.</p> </li> <li> <code>parse_tmdl_expressions</code>             \u2013              <p>Parse the expressions from the 'expressions.tmdl' file.</p> </li> <li> <code>parse_tmdl_relationships</code>             \u2013              <p>Parse the relationships from the 'relationships.tmdl' file.</p> </li> <li> <code>parse_tmdl_tables</code>             \u2013              <p>Parse all .tmdl files in the 'definition/tables' folder.</p> </li> <li> <code>parse_tmsl</code>             \u2013              <p>Parse the TMSL model from the semantic folder.</p> </li> <li> <code>run_expectations</code>             \u2013              <p>Executes all registered expectation functions against the model.</p> </li> </ul> Source code in <code>pbipinspect/inspect.py</code> <pre><code>def __init__(\n    self, \n    name: str | Path,\n    semantic_folder: str | Path,\n    report_folder: str | Path\n) -&gt; None:\n    \"\"\"\n    Initialize the PbipInspect object with a given name, semantic folder and report folder.\n\n    Parameters\n    ----------\n    name : str | Path\n        The name of the .pbip file.\n    semantic_folder : str | Path\n        The path of the semantic model folder.\n    report_folder : str | Path\n        The path of the report folder.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    self.name = name\n    self.semantic_folder = semantic_folder\n    self.report_folder = report_folder\n    self._pbip = self.parse_pbip()\n    self.steps: list[Callable] = []\n    self.expects: list[ExpectMessage] = []\n    self.metadata: dict = {}\n</code></pre>"},{"location":"reference/inspect/#pbipinspect.inspect.PbipInspect.add_metadata","title":"<code>add_metadata(metadata: dict)</code>","text":"<p>Add metadata to the report.</p> <p>Parameters:</p> <ul> <li> <code>metadata</code>               (<code>dict</code>)           \u2013            <p>A dictionary of metadata to be added to the report.</p> </li> </ul> Source code in <code>pbipinspect/inspect.py</code> <pre><code>def add_metadata(self, metadata: dict):\n    \"\"\"\n    Add metadata to the report.\n\n    Parameters\n    ----------\n    metadata : dict\n        A dictionary of metadata to be added to the report.\n    \"\"\"\n    self.metadata = metadata\n</code></pre>"},{"location":"reference/inspect/#pbipinspect.inspect.PbipInspect.expectations","title":"<code>expectations(steps: list[Callable])</code>","text":"<p>Register a list of expectation functions to run against the model.</p> <p>Parameters:</p> <ul> <li> <code>steps</code>               (<code>list[Callable]</code>)           \u2013            <p>A list of functions that take a Pbip object as an argument and return a list of ExpectMessage.</p> </li> </ul> Source code in <code>pbipinspect/inspect.py</code> <pre><code>def expectations(self, steps: list[Callable]):\n    \"\"\"\n    Register a list of expectation functions to run against the model.\n\n    Parameters\n    ----------\n    steps : list[Callable]\n        A list of functions that take a Pbip object as an argument and return a list of ExpectMessage.\n    \"\"\"\n    self.steps = steps\n</code></pre>"},{"location":"reference/inspect/#pbipinspect.inspect.PbipInspect.parse_pbip","title":"<code>parse_pbip() -&gt; Pbip</code>","text":"<p>Parse the PBIP model from the semantic folder.</p> <p>Returns:</p> <ul> <li> <code>Pbip</code>           \u2013            <p>An object representing the parsed model, containing the model and a method to run expectations.</p> </li> </ul> Source code in <code>pbipinspect/inspect.py</code> <pre><code>def parse_pbip(self) -&gt; Pbip:\n    \"\"\"\n    Parse the PBIP model from the semantic folder.\n\n    Returns\n    -------\n    Pbip\n        An object representing the parsed model, containing the model and a method to run expectations.\n    \"\"\"\n    tmsl_check = is_TMSL(self.semantic_folder)\n    parse = self.parse_tmsl if tmsl_check else self.parse_tmdl\n    final_model = parse()\n    return Pbip(final_model)\n</code></pre>"},{"location":"reference/inspect/#pbipinspect.inspect.PbipInspect.parse_relationships_to_mermaid","title":"<code>parse_relationships_to_mermaid(content: dict) -&gt; str</code>  <code>staticmethod</code>","text":"<p>Given a JSON content describing Power BI relationships, this function returns a string in Mermaid flowchart format that shows each table (as a subgraph) with its columns, and draws arrows representing the relationships with cardinality labels.</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>dict</code>)           \u2013            <p>A dictionary representing the model, containing lists of tables and relationships.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>A string in Mermaid flowchart format.</p> </li> </ul> Source code in <code>pbipinspect/inspect.py</code> <pre><code>@staticmethod\ndef parse_relationships_to_mermaid(content: dict) -&gt; str:\n    \"\"\"\n    Given a JSON content describing Power BI relationships,\n    this function returns a string in Mermaid flowchart format that shows each table (as a subgraph)\n    with its columns, and draws arrows representing the relationships with cardinality labels.\n\n    Parameters\n    ----------\n    content : dict\n        A dictionary representing the model, containing lists of tables and relationships.\n\n    Returns\n    -------\n    str\n        A string in Mermaid flowchart format.\n    \"\"\"\n    relationships = content.get('relationships', [])\n    table_columns: dict = {}\n    for rel in relationships:\n        from_table, from_column = rel.get('fromTable'), rel.get('fromColumn')\n        to_table, to_column = rel.get('toTable'), rel.get('toColumn')\n        if from_table and from_column:\n            table_columns.setdefault(from_table, set()).add(from_column)\n        if to_table and to_column:\n            table_columns.setdefault(to_table, set()).add(to_column)\n\n    table_subgraph_ids = {}\n    node_ids = {}\n    subgraph_lines = []\n    node_counter, subgraph_counter = 1, 1\n\n    for table in sorted(table_columns.keys()):\n        columns = table_columns[table]\n        subgraph_id = f\"s{subgraph_counter}\"\n        table_subgraph_ids[table] = subgraph_id\n        subgraph_counter += 1\n\n        sub_lines = [f'subgraph {subgraph_id}[\"{table}\"]']\n        for col in sorted(columns):\n            node_id = f\"n{node_counter}\"\n            node_ids[(table, col)] = node_id\n            node_counter += 1\n            sub_lines.append(f'{node_id}[\"{col}\"]')\n        sub_lines.append(\"end\")\n        subgraph_lines.append(\"\\n\".join(sub_lines))\n\n    relationship_lines = []\n    for rel in relationships:\n        from_table, from_column = rel.get('fromTable'), rel.get('fromColumn')\n        to_table, to_column = rel.get('toTable'), rel.get('toColumn')\n        from_node = node_ids.get((from_table, from_column))\n        to_node = node_ids.get((to_table, to_column))\n        from_card, to_card = rel.get('fromCardinalitySymbol', ''), rel.get('toCardinalitySymbol', '')\n        from_card_mermaid = f'\\\\{from_card}' if from_card == '*' else from_card\n        filtering_symbol = rel.get('filteringSymbol')\n        line = f'{from_node} -- {from_card_mermaid} {filtering_symbol} {to_card} --- {to_node}'\n        relationship_lines.append(line)\n\n    mermaid_lines = ['flowchart LR']\n    mermaid_lines.extend(subgraph_lines)\n    mermaid_lines.extend(relationship_lines)\n    return \"\\n\".join(mermaid_lines)\n</code></pre>"},{"location":"reference/inspect/#pbipinspect.inspect.PbipInspect.parse_tmdl","title":"<code>parse_tmdl() -&gt; dict</code>","text":"<p>Parse the TMDL model from the semantic folder.</p> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>A dictionary representing the model, containing lists of tables and relationships.</p> </li> </ul> Source code in <code>pbipinspect/inspect.py</code> <pre><code>def parse_tmdl(self) -&gt; dict:\n    \"\"\"\n    Parse the TMDL model from the semantic folder.\n\n    Returns\n    -------\n    dict\n        A dictionary representing the model, containing lists of tables and relationships.\n    \"\"\"\n    final_model: dict = {\n        'model': {\n            'tables': [],\n            'relationships': [],\n            'expressions': []\n        }\n    }\n    final_model['model']['tables'] = self.parse_tmdl_tables()\n    final_model['model']['relationships'] = self.parse_tmdl_relationships()\n    final_model['model']['expressions'] = self.parse_tmdl_expressions()\n    return final_model\n</code></pre>"},{"location":"reference/inspect/#pbipinspect.inspect.PbipInspect.parse_tmdl_expressions","title":"<code>parse_tmdl_expressions() -&gt; list[dict]</code>","text":"<p>Parse the expressions from the 'expressions.tmdl' file.</p> <p>Returns:</p> <ul> <li> <code>list[dict] | None</code>           \u2013            <p>If the 'definition/tables' folder does not exist, return None. Otherwise, return a list of dictionaries with expression details.</p> </li> </ul> Source code in <code>pbipinspect/inspect.py</code> <pre><code>def parse_tmdl_expressions(self) -&gt; list[dict]:\n    \"\"\"\n    Parse the expressions from the 'expressions.tmdl' file.\n\n    Returns\n    -------\n    list[dict] | None\n        If the 'definition/tables' folder does not exist, return None.\n        Otherwise, return a list of dictionaries with expression details.\n    \"\"\"\n    folder = self.semantic_folder\n    check = has_table_folder(folder)\n    if not check:\n        return []\n    expression = get_tmdl_expression_file(folder)\n    if Path(expression).is_file() == False: \n        return []\n    content = expression.read_text(encoding='utf-8')\n    parsed_expression = get_tmdl_expressions(content)\n    return parsed_expression\n</code></pre>"},{"location":"reference/inspect/#pbipinspect.inspect.PbipInspect.parse_tmdl_relationships","title":"<code>parse_tmdl_relationships() -&gt; list[dict]</code>","text":"<p>Parse the relationships from the 'relationships.tmdl' file.</p> <p>Returns:</p> <ul> <li> <code>list[dict] | None</code>           \u2013            <p>If the 'definition/tables' folder does not exist, return None. Otherwise, return a list of dictionaries with relationship details.</p> </li> </ul> Source code in <code>pbipinspect/inspect.py</code> <pre><code>def parse_tmdl_relationships(self) -&gt; list[dict]:\n    \"\"\"\n    Parse the relationships from the 'relationships.tmdl' file.\n\n    Returns\n    -------\n    list[dict] | None\n        If the 'definition/tables' folder does not exist, return None.\n        Otherwise, return a list of dictionaries with relationship details.\n    \"\"\"\n    folder = self.semantic_folder\n    check = has_table_folder(folder)\n    if not check:\n        return []\n    relationship = get_tmdl_relationship_file(folder)\n    if Path(relationship).is_file() == False: \n        return []\n    content = relationship.read_text(encoding='utf-8')\n    parsed_relationship = get_tmdl_relationship(content)\n    return parsed_relationship\n</code></pre>"},{"location":"reference/inspect/#pbipinspect.inspect.PbipInspect.parse_tmdl_tables","title":"<code>parse_tmdl_tables() -&gt; list[dict] | None</code>","text":"<p>Parse all .tmdl files in the 'definition/tables' folder.</p> <p>Returns:</p> <ul> <li> <code>list[dict] | None</code>           \u2013            <p>If the 'definition/tables' folder does not exists, return None. Otherwise, return a list of dictionaries, each one representing a table.</p> </li> </ul> Source code in <code>pbipinspect/inspect.py</code> <pre><code>def parse_tmdl_tables(self) -&gt; list[dict] | None:\n    \"\"\"\n    Parse all .tmdl files in the 'definition/tables' folder.\n\n    Returns\n    -------\n    list[dict] | None\n        If the 'definition/tables' folder does not exists, return None.\n        Otherwise, return a list of dictionaries, each one representing a table.\n    \"\"\"\n    folder = self.semantic_folder\n    check = has_table_folder(folder)\n    if not check:\n        return None\n    tables = get_tmdl_table_files(folder)\n    parsed_tables = []\n    for table in tables:\n        content = table.read_text(encoding='utf-8')\n        tmdl_parsed = get_tmdl_table(content)\n        parsed_tables.append(tmdl_parsed)\n    return parsed_tables\n</code></pre>"},{"location":"reference/inspect/#pbipinspect.inspect.PbipInspect.parse_tmsl","title":"<code>parse_tmsl() -&gt; dict</code>","text":"<p>Parse the TMSL model from the semantic folder.</p> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>A dictionary representing the model, containing lists of tables and relationships.</p> </li> </ul> Source code in <code>pbipinspect/inspect.py</code> <pre><code>def parse_tmsl(self) -&gt; dict:\n    \"\"\"\n    Parse the TMSL model from the semantic folder.\n\n    Returns\n    -------\n    dict\n        A dictionary representing the model, containing lists of tables and relationships.\n    \"\"\"\n    model_bim = build_tmsl_path(self.semantic_folder)\n    with open(model_bim, 'r', encoding='utf-8') as f:\n        tmsl = json.load(f)\n    final_model = clean_tmsl(tmsl)\n    return final_model\n</code></pre>"},{"location":"reference/inspect/#pbipinspect.inspect.PbipInspect.run_expectations","title":"<code>run_expectations()</code>","text":"<p>Executes all registered expectation functions against the model.</p> <p>The method iterates over the list of expectation functions stored in <code>self.steps</code>  and applies each function to the model. It collects the results, which are lists  of <code>ExpectMessage</code> dictionaries, and flattens them into a single list stored in  <code>self.expects</code>.</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul> Source code in <code>pbipinspect/inspect.py</code> <pre><code>def run_expectations(self):\n    \"\"\"\n    Executes all registered expectation functions against the model.\n\n    The method iterates over the list of expectation functions stored in `self.steps` \n    and applies each function to the model. It collects the results, which are lists \n    of `ExpectMessage` dictionaries, and flattens them into a single list stored in \n    `self.expects`.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    results = []\n    for expect in self.steps:\n        results.append(expect(self.pbip))\n    self.expects = [x for y in results for x in y]\n</code></pre>"},{"location":"reference/inspect/#pbipinspect.inspect.create_inspect","title":"<code>create_inspect(path: str | Path) -&gt; PbipInspect</code>","text":"<p>Create a PbipInspect object from a given path, which can be a .pbip file or a directory  containing .pbip files. Validates the presence and uniqueness of .pbip files, and verifies  the existence of required folders.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str | Path</code>)           \u2013            <p>The path to a specific .pbip file or a directory that may contain .pbip files.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PbipInspect</code>           \u2013            <p>An instance of PbipInspect initialized with the .pbip file's name, semantic folder,  and report folder.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>PbipNotFoundError</code>             \u2013            <p>If no .pbip file is found in the specified directory.</p> </li> <li> <code>MultiplePbipFilesError</code>             \u2013            <p>If more than one .pbip file is found in the specified directory.</p> </li> <li> <code>SemanticModelFolderNotFoundError</code>             \u2013            <p>If the semantic folder does not exist.</p> </li> </ul> Source code in <code>pbipinspect/inspect.py</code> <pre><code>def create_inspect(path: str | Path) -&gt; PbipInspect:\n    \"\"\"\n    Create a PbipInspect object from a given path, which can be a .pbip file or a directory \n    containing .pbip files. Validates the presence and uniqueness of .pbip files, and verifies \n    the existence of required folders.\n\n    Parameters\n    ----------\n    path : str | Path\n        The path to a specific .pbip file or a directory that may contain .pbip files.\n\n    Returns\n    -------\n    PbipInspect\n        An instance of PbipInspect initialized with the .pbip file's name, semantic folder, \n        and report folder.\n\n    Raises\n    ------\n    PbipNotFoundError\n        If no .pbip file is found in the specified directory.\n    MultiplePbipFilesError\n        If more than one .pbip file is found in the specified directory.\n    SemanticModelFolderNotFoundError\n        If the semantic folder does not exist.\n    \"\"\"\n    check_pbip = is_pbip_file(path)\n    pbips = [Path(path)] if check_pbip else find_pbip_file(path)\n\n    if not pbips:\n        raise PbipNotFoundError(path)\n\n    if len(pbips) &gt; 1:\n        raise MultiplePbipFilesError(path, pbips)\n\n    pbip = pbips[0]\n    pbip_name = get_pbip_name(pbip)\n    semantic_folder = get_semantic_model_path(pbip)\n\n    if not semantic_folder.is_dir():\n        raise SemanticModelFolderNotFoundError(semantic_folder)\n\n    report_folder = get_report_path(pbip)\n    inspect = PbipInspect(pbip_name, semantic_folder, report_folder)\n    return inspect\n</code></pre>"},{"location":"reference/pbip/","title":"pbip","text":"<p>Classes:</p> <ul> <li> <code>Pbip</code>           \u2013            <p>A class that represents pbip model.</p> </li> </ul>"},{"location":"reference/pbip/#pbipinspect.pbip.Pbip","title":"<code>Pbip(model: dict)</code>","text":"<p>A class that represents pbip model.</p> <p>Parameters:</p> <ul> <li> <code>model</code>               (<code>dict</code>)           \u2013            <p>The model dictionary containing the data structure.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>get_fields</code>             \u2013              <p>Retrieve fields from tables based on the specified key.</p> </li> <li> <code>get_table_column</code>             \u2013              <p>Get a column of a table.</p> </li> <li> <code>get_table_field</code>             \u2013              <p>Get a field of a table.</p> </li> <li> <code>get_table_measure</code>             \u2013              <p>Retrieve a specific measure from a table.</p> </li> </ul> Source code in <code>pbipinspect/pbip.py</code> <pre><code>def __init__(self, model: dict) -&gt; None:\n    \"\"\"\n    Initialize the Pbip object with a given model.\n\n    Parameters\n    ----------\n    model : dict\n        The model dictionary containing the data structure.\n    \"\"\"\n    self._model = model\n</code></pre>"},{"location":"reference/pbip/#pbipinspect.pbip.Pbip.get_fields","title":"<code>get_fields(x: str) -&gt; list[dict]</code>","text":"<p>Retrieve fields from tables based on the specified key.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>str</code>)           \u2013            <p>The key to access specific fields in the table, such as 'columns' or 'measures'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[dict]</code>           \u2013            <p>A list of dictionaries, each containing the fields from the tables along with the table name.</p> </li> </ul> Source code in <code>pbipinspect/pbip.py</code> <pre><code>def get_fields(self, x: str) -&gt; list[dict]:\n    \"\"\"\n    Retrieve fields from tables based on the specified key.\n\n    Parameters\n    ----------\n    x : str\n        The key to access specific fields in the table, such as 'columns' or 'measures'.\n\n    Returns\n    -------\n    list[dict]\n        A list of dictionaries, each containing the fields from the tables along with the table name.\n    \"\"\"\n    fields = []\n    for table in self.tables:\n        for column in table[x]:\n            fields.append(column | {'table': table['name']})\n    return fields\n</code></pre>"},{"location":"reference/pbip/#pbipinspect.pbip.Pbip.get_table_column","title":"<code>get_table_column(table: str, column: str) -&gt; dict | None</code>","text":"<p>Get a column of a table.</p> <p>Parameters:</p> <ul> <li> <code>table</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> <li> <code>column</code>               (<code>str</code>)           \u2013            <p>The name of the column.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict | None</code>           \u2013            <p>The column of the table, or None if the table or column does not exist.</p> </li> </ul> Source code in <code>pbipinspect/pbip.py</code> <pre><code>def get_table_column(self, table: str, column: str) -&gt; dict | None:\n    \"\"\"\n    Get a column of a table.\n\n    Parameters\n    ----------\n    table : str\n        The name of the table.\n    column : str\n        The name of the column.\n\n    Returns\n    -------\n    dict | None\n        The column of the table, or None if the table or column does not exist.\n    \"\"\"\n    if table not in [x['name'] for x in self.tables]:\n        return None\n    for t in self.tables:\n        column_names = [x['name'] for x in t['columns']]\n        if t['name'] == table and column in column_names:\n            return t['columns'][column_names.index(column)]\n    return None\n</code></pre>"},{"location":"reference/pbip/#pbipinspect.pbip.Pbip.get_table_field","title":"<code>get_table_field(table: str, field: str) -&gt; list | None</code>","text":"<p>Get a field of a table.</p> <p>Parameters:</p> <ul> <li> <code>table</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> <li> <code>field</code>               (<code>str</code>)           \u2013            <p>The name of the field.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list | None</code>           \u2013            <p>The field of the table, or None if the table or field does not exist.</p> </li> </ul> Source code in <code>pbipinspect/pbip.py</code> <pre><code>def get_table_field(self, table: str, field: str) -&gt; list | None:\n    \"\"\"\n    Get a field of a table.\n\n    Parameters\n    ----------\n    table : str\n        The name of the table.\n    field : str\n        The name of the field.\n\n    Returns\n    -------\n    list | None\n        The field of the table, or None if the table or field does not exist.\n    \"\"\"\n    if table not in [x['name'] for x in self.tables]:\n        return None\n    for t in self.tables:\n        if t['name'] == table and field in t:\n            return t[field]\n    return None\n</code></pre>"},{"location":"reference/pbip/#pbipinspect.pbip.Pbip.get_table_measure","title":"<code>get_table_measure(table: str, measure: str) -&gt; dict | None</code>","text":"<p>Retrieve a specific measure from a table.</p> <p>Parameters:</p> <ul> <li> <code>table</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> <li> <code>measure</code>               (<code>str</code>)           \u2013            <p>The name of the measure.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict | None</code>           \u2013            <p>The measure from the table, or None if the table or measure does not exist.</p> </li> </ul> Source code in <code>pbipinspect/pbip.py</code> <pre><code>def get_table_measure(self, table: str, measure: str) -&gt; dict | None:\n    \"\"\"\n    Retrieve a specific measure from a table.\n\n    Parameters\n    ----------\n    table : str\n        The name of the table.\n    measure : str\n        The name of the measure.\n\n    Returns\n    -------\n    dict | None\n        The measure from the table, or None if the table or measure does not exist.\n    \"\"\"\n    if table not in [x['name'] for x in self.tables]:\n        return None\n    for t in self.tables:\n        measure_names = [x['name'] for x in t['measures']]\n        if t['name'] == table and measure in measure_names:\n            return t['measures'][measure_names.index(measure)]\n    return None\n</code></pre>"},{"location":"reference/utils/","title":"utils","text":"<p>Functions:</p> <ul> <li> <code>check_lines_max_length</code>             \u2013              <p>Checks if any line in a given string exceeds the maximum length.</p> </li> <li> <code>fix_duplicate_ids</code>             \u2013              <p>Finds duplicate HTML id attributes and markdown links (e.g. text)</p> </li> <li> <code>get_regex_group</code>             \u2013              <p>Extracts a specified group from a regex match within a given string.</p> </li> <li> <code>quote_and_join</code>             \u2013              <p>Joins a list of strings with a separator, single-quoting each string.</p> </li> <li> <code>sanitize_id</code>             \u2013              <p>Transforms a given string into a valid Markdown-friendly ID.</p> </li> <li> <code>smart_join</code>             \u2013              <p>Joins a list of strings into a single string formatted in a human-readable way.</p> </li> </ul>"},{"location":"reference/utils/#pbipinspect.utils.check_lines_max_length","title":"<code>check_lines_max_length(x: str, max_length: int) -&gt; list[tuple[str, str]]</code>","text":"<p>Checks if any line in a given string exceeds the maximum length.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>str</code>)           \u2013            <p>The input string to check.</p> </li> <li> <code>max_length</code>               (<code>int</code>)           \u2013            <p>The maximum length of a line.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[tuple[str, str]]</code>           \u2013            <p>A list of tuples, where the first element of the tuple is the line number (1-indexed) and the second element is the line itself, if the line exceeds the maximum length. If no lines exceed the maximum length, an empty list is returned.</p> </li> </ul> Source code in <code>pbipinspect/utils.py</code> <pre><code>def check_lines_max_length(x: str, max_length: int) -&gt; list[tuple[str, str]]:\n    \"\"\"\n    Checks if any line in a given string exceeds the maximum length.\n\n    Parameters\n    ----------\n    x : str\n        The input string to check.\n    max_length : int\n        The maximum length of a line.\n\n    Returns\n    -------\n    list[tuple[str, str]]\n        A list of tuples, where the first element of the tuple is the line\n        number (1-indexed) and the second element is the line itself, if the\n        line exceeds the maximum length. If no lines exceed the maximum length,\n        an empty list is returned.\n    \"\"\"\n    lines = x.split('\\n')\n    len_check = [\n        (str(i + 1), x) \n        for i, x in enumerate(lines) \n        if len(x) &gt; max_length\n    ]\n    return len_check\n</code></pre>"},{"location":"reference/utils/#pbipinspect.utils.fix_duplicate_ids","title":"<code>fix_duplicate_ids(text: str) -&gt; str</code>","text":"<p>Finds duplicate HTML id attributes and markdown links (e.g. text) and fixes them so that each occurrence is unique.</p> <p>For HTML tag attributes (like id=\"Duplicate\"), the first occurrence remains unchanged, the second becomes \"Duplicate1\", the third \"Duplicate2\", etc.</p> <p>For markdown links, we assume that the intended target should follow the same order. For example, the first markdown link referencing \"#Duplicate\" will be changed to point to the first occurrence (i.e. \"#Duplicate\"), the second will be changed to \"#Duplicate1\", etc.</p> <p>Code blocks (demarcated by \"```\") are left unmodified.</p> <p>Parameters:</p> <ul> <li> <code>text</code>               (<code>str</code>)           \u2013            <p>The rendered text to fix duplicate ids and markdown links in.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The rendered text with duplicate ids and markdown links fixed.</p> </li> </ul> Source code in <code>pbipinspect/utils.py</code> <pre><code>def fix_duplicate_ids(text: str) -&gt; str:\n    \"\"\"\n    Finds duplicate HTML id attributes and markdown links (e.g. [text](#id))\n    and fixes them so that each occurrence is unique.\n\n    For HTML tag attributes (like id=\"Duplicate\"), the first occurrence remains\n    unchanged, the second becomes \"Duplicate1\", the third \"Duplicate2\", etc.\n\n    For markdown links, we assume that the intended target should follow the\n    same order. For example, the first markdown link referencing \"#Duplicate\" will\n    be changed to point to the first occurrence (i.e. \"#Duplicate\"), the second will\n    be changed to \"#Duplicate1\", etc.\n\n    Code blocks (demarcated by \"```\") are left unmodified.\n\n    Parameters\n    ----------\n    text : str\n        The rendered text to fix duplicate ids and markdown links in.\n\n    Returns\n    -------\n    str\n        The rendered text with duplicate ids and markdown links fixed.\n    \"\"\"\n    id_mapping = defaultdict(list)\n    counts: dict = defaultdict(int)\n    link_counts: dict = defaultdict(int)\n\n    id_attr_pattern = re.compile(r'(\\bid=\")([^\"]+)(\")')\n    md_link_pattern = re.compile(r'(\\]\\(#)([^)]+)(\\))')\n\n    def replace_html_id(match):\n        prefix, orig_id, suffix = match.groups()\n        cnt = counts[orig_id]\n        new_id = orig_id if cnt == 0 else f\"{orig_id}{cnt}\"\n        counts[orig_id] += 1\n        id_mapping[orig_id].append(new_id)\n        return f'{prefix}{new_id}{suffix}'\n\n    def replace_md_link(match):\n        prefix, orig_id, suffix = match.groups()\n        if orig_id not in id_mapping or not id_mapping[orig_id]:\n            return match.group(0)\n        cnt = link_counts[orig_id]\n        if cnt &lt; len(id_mapping[orig_id]):\n            new_target = id_mapping[orig_id][cnt]\n        else:\n            new_target = id_mapping[orig_id][0]\n        link_counts[orig_id] += 1\n        return f'{prefix}{new_target}{suffix}'\n\n    code_block_pattern = re.compile(r'(```[\\s\\S]*?```)', re.MULTILINE)\n    segments = code_block_pattern.split(text)\n\n    for i, segment in enumerate(segments):\n        if i % 2 == 0:\n            segment = id_attr_pattern.sub(replace_html_id, segment)\n            segment = md_link_pattern.sub(replace_md_link, segment)\n            segments[i] = segment\n\n    fixed_text = \"\".join(segments)\n    return fixed_text\n</code></pre>"},{"location":"reference/utils/#pbipinspect.utils.get_regex_group","title":"<code>get_regex_group(x: str, pattern: str | re.Pattern[str], group: int = 1, if_none: Any = None) -&gt; Any</code>","text":"<p>Extracts a specified group from a regex match within a given string.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>str</code>)           \u2013            <p>The input string to search for the regex pattern.</p> </li> <li> <code>pattern</code>               (<code>str or Pattern</code>)           \u2013            <p>The regex pattern used to search within the input string.</p> </li> <li> <code>group</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>The group number to extract from the match, defaults to 1.</p> </li> <li> <code>if_none</code>               (<code>Any</code>, default:                   <code>None</code> )           \u2013            <p>The value to return if no match is found, defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>The specified regex group if a match is found, otherwise returns <code>if_none</code>.</p> </li> </ul> Source code in <code>pbipinspect/utils.py</code> <pre><code>def get_regex_group(\n    x: str, \n    pattern: str | re.Pattern[str],\n    group: int = 1,\n    if_none: Any = None\n) -&gt; Any:\n    \"\"\"\n    Extracts a specified group from a regex match within a given string.\n\n    Parameters\n    ----------\n    x : str\n        The input string to search for the regex pattern.\n    pattern : str or re.Pattern\n        The regex pattern used to search within the input string.\n    group : int, optional\n        The group number to extract from the match, defaults to 1.\n    if_none : Any, optional\n        The value to return if no match is found, defaults to None.\n\n    Returns\n    -------\n    Any\n        The specified regex group if a match is found, otherwise returns `if_none`.\n    \"\"\"\n\n    match = re.search(pattern, x)\n    if match is None:\n        return if_none\n    return match.group(group)\n</code></pre>"},{"location":"reference/utils/#pbipinspect.utils.quote_and_join","title":"<code>quote_and_join(strings: list[str], sep=', ')</code>","text":"<p>Joins a list of strings with a separator, single-quoting each string.</p> <p>Parameters:</p> <ul> <li> <code>strings</code>               (<code>list[str]</code>)           \u2013            <p>The list of strings to join.</p> </li> <li> <code>sep</code>               (<code>str</code>, default:                   <code>', '</code> )           \u2013            <p>The separator to use when joining the strings, defaults to ', '.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The joined string.</p> </li> </ul> Source code in <code>pbipinspect/utils.py</code> <pre><code>def quote_and_join(strings: list[str], sep=', '):\n    \"\"\"\n    Joins a list of strings with a separator, single-quoting each string.\n\n    Parameters\n    ----------\n    strings : list[str]\n        The list of strings to join.\n    sep : str, optional\n        The separator to use when joining the strings, defaults to ', '.\n\n    Returns\n    -------\n    str\n        The joined string.\n    \"\"\"\n    return sep.join(f\"'{s}'\" for s in strings)\n</code></pre>"},{"location":"reference/utils/#pbipinspect.utils.sanitize_id","title":"<code>sanitize_id(text: str) -&gt; str</code>","text":"<p>Transforms a given string into a valid Markdown-friendly ID.</p> <ul> <li>Converts to lowercase</li> <li>Replaces spaces with hyphens</li> <li>Removes special characters except hyphens and alphanumerics</li> </ul> <p>Parameters:</p> <ul> <li> <code>text</code>               (<code>str</code>)           \u2013            <p>The string to sanitize</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The sanitized string</p> </li> </ul> Source code in <code>pbipinspect/utils.py</code> <pre><code>def sanitize_id(text: str) -&gt; str:\n    \"\"\"\n    Transforms a given string into a valid Markdown-friendly ID.\n\n    - Converts to lowercase\n    - Replaces spaces with hyphens\n    - Removes special characters except hyphens and alphanumerics\n\n    Parameters\n    ----------\n    text : str\n        The string to sanitize\n\n    Returns\n    -------\n    str\n        The sanitized string\n    \"\"\"\n    text = text.lower() \n    text = re.sub(r'\\s+', '-', text)\n    text = re.sub(r'[^a-z0-9\\-]', '', text)\n    return text\n</code></pre>"},{"location":"reference/utils/#pbipinspect.utils.smart_join","title":"<code>smart_join(strings: list[str])</code>","text":"<p>Joins a list of strings into a single string formatted in a human-readable way.</p> <p>Parameters:</p> <ul> <li> <code>strings</code>               (<code>list[str]</code>)           \u2013            <p>The list of strings to join.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>A single string with the elements joined. If the list is empty, returns an  empty string. If there is one element, returns the element quoted. If there  are two elements, joins them with 'and'. For more than two elements, joins  all but the last with commas, and the last with 'and'.</p> </li> </ul> Source code in <code>pbipinspect/utils.py</code> <pre><code>def smart_join(strings: list[str]):\n    \"\"\"\n    Joins a list of strings into a single string formatted in a human-readable way.\n\n    Parameters\n    ----------\n    strings : list[str]\n        The list of strings to join.\n\n    Returns\n    -------\n    str\n        A single string with the elements joined. If the list is empty, returns an \n        empty string. If there is one element, returns the element quoted. If there \n        are two elements, joins them with 'and'. For more than two elements, joins \n        all but the last with commas, and the last with 'and'.\n    \"\"\"\n    if not strings:\n        return ''\n    elif len(strings) == 1:\n        return f\"'{strings[0]}'\"\n    elif len(strings) == 2:\n        return quote_and_join(strings, ' and ')\n    else:\n        return quote_and_join(strings[:-1], ', ') + ' and ' + f\"'{strings[-1]}'\"\n</code></pre>"},{"location":"reference/parse/tmdl/","title":"tmdl","text":"<p>Functions:</p> <ul> <li> <code>get_table_columns</code>             \u2013              <p>Parse columns from the given tmdl string.</p> </li> <li> <code>get_table_measures</code>             \u2013              <p>Parse measures from the given tmdl string.</p> </li> <li> <code>get_table_partitions</code>             \u2013              <p>Parse partitions from the given tmdl string.</p> </li> <li> <code>get_tmdl_relationship</code>             \u2013              <p>Parse the relationships from a given TMDL content.</p> </li> <li> <code>get_tmdl_table</code>             \u2013              <p>Reads a .tmdl file and returns a dictionary containing the table information</p> </li> </ul>"},{"location":"reference/parse/tmdl/#pbipinspect.parse.tmdl.get_table_columns","title":"<code>get_table_columns(tmdl: str) -&gt; list[dict]</code>","text":"<p>Parse columns from the given tmdl string.</p> <p>Parameters:</p> <ul> <li> <code>tmdl</code>               (<code>str</code>)           \u2013            <p>TMDL string</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[dict]</code>           \u2013            <p>A list of dictionaries containing column information. Each dictionary has the following keys: - name: str - expression: str - isHidden: bool - isNameInferred: bool - dataType: str | None - lineageTag: str | None - summarizeBy: str | None - sourceColumn: str | None - annotations: list[dict] | None - calculated: bool</p> </li> </ul> Source code in <code>pbipinspect/parse/tmdl.py</code> <pre><code>def get_table_columns(tmdl: str) -&gt; list[dict]:\n    \"\"\"\n    Parse columns from the given tmdl string.\n\n    Parameters\n    ----------\n    tmdl : str\n        TMDL string\n\n    Returns\n    -------\n    list[dict]\n        A list of dictionaries containing column information. Each dictionary has the following keys:\n        - name: str\n        - expression: str\n        - isHidden: bool\n        - isNameInferred: bool\n        - dataType: str | None\n        - lineageTag: str | None\n        - summarizeBy: str | None\n        - sourceColumn: str | None\n        - annotations: list[dict] | None\n        - calculated: bool\n    \"\"\"\n    content = get_table_columns_content(tmdl)\n    columns = []\n    for cur_value in content:\n        name, expression = get_table_column_name_expression(cur_value)\n        data_type = get_table_column_data_type(cur_value)\n        is_hidden = 'isHidden' in cur_value\n        is_name_inferred = 'isNameInferred' in cur_value\n        lineage_tag = get_lineage_tag(cur_value)\n        summarize_by = get_table_summarize_by(cur_value)\n        source_column = get_table_source_column(cur_value)\n        annotations = get_annotations(cur_value)\n        columns.append({\n            'name': name,\n            'expression': expression,\n            'isHidden': is_hidden,\n            'isNameInferred': is_name_inferred,\n            'dataType': data_type,\n            'lineageTag': lineage_tag,\n            'summarizeBy': summarize_by,\n            'sourceColumn': source_column,\n            'annotations': annotations,\n            'calculated': str(source_column).startswith('[') or expression\n        })\n    return columns\n</code></pre>"},{"location":"reference/parse/tmdl/#pbipinspect.parse.tmdl.get_table_measures","title":"<code>get_table_measures(tmdl: str) -&gt; list[dict]</code>","text":"<p>Parse measures from the given tmdl string.</p> <p>Parameters:</p> <ul> <li> <code>tmdl</code>               (<code>str</code>)           \u2013            <p>TMDL string</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[dict]</code>           \u2013            <p>A list of dictionaries containing measure information. Each dictionary has the following keys: - name: str - formatString: str | None - annotations: list[str] - displayFolder: str | None - lineageTag: str | None - expression: str - description: str - references: list[str]</p> </li> </ul> Source code in <code>pbipinspect/parse/tmdl.py</code> <pre><code>def get_table_measures(tmdl: str) -&gt; list[dict]:\n    \"\"\"\n    Parse measures from the given tmdl string.\n\n    Parameters\n    ----------\n    tmdl : str\n        TMDL string\n\n    Returns\n    -------\n    list[dict]\n        A list of dictionaries containing measure information. Each dictionary has the following keys:\n        - name: str\n        - formatString: str | None\n        - annotations: list[str]\n        - displayFolder: str | None\n        - lineageTag: str | None\n        - expression: str\n        - description: str\n        - references: list[str]\n    \"\"\"\n    content = get_table_measure_content(tmdl)\n    measures = []\n    for cur_value in content:\n        name = get_table_measure_name(cur_value)\n        format_string = get_table_measure_format_string(cur_value)\n        display_folder = get_table_measure_display_folder(cur_value)\n        lineage_tag = get_lineage_tag(cur_value)\n        annotations = get_annotations(cur_value)\n        expression = get_table_measure_expression(cur_value)\n        description = get_measure_description(cur_value)\n        references = get_measure_references(expression)\n        measures.append({\n            'name': name,\n            'formatString': format_string,\n            'annotations': annotations,\n            'displayFolder': display_folder,\n            'lineageTag': lineage_tag,\n            'expression': expression,\n            'description': description,\n            'references': references\n        })\n    return measures\n</code></pre>"},{"location":"reference/parse/tmdl/#pbipinspect.parse.tmdl.get_table_partitions","title":"<code>get_table_partitions(tmdl: str) -&gt; list[dict]</code>","text":"<p>Parse partitions from the given tmdl string.</p> <p>Parameters:</p> <ul> <li> <code>tmdl</code>               (<code>str</code>)           \u2013            <p>TMDL string</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[dict]</code>           \u2013            <p>A list of dictionaries containing partition information. Each dictionary has the following keys: - name: str - type: str - mode: str - raw_expression: str - expression: str - description: str</p> </li> </ul> Source code in <code>pbipinspect/parse/tmdl.py</code> <pre><code>def get_table_partitions(tmdl: str) -&gt; list[dict]:\n    \"\"\"\n    Parse partitions from the given tmdl string.\n\n    Parameters\n    ----------\n    tmdl : str\n        TMDL string\n\n    Returns\n    -------\n    list[dict]\n        A list of dictionaries containing partition information. Each dictionary has the following keys:\n        - name: str\n        - type: str\n        - mode: str\n        - raw_expression: str\n        - expression: str\n        - description: str\n    \"\"\"\n    content = get_table_partition_content(tmdl)\n    partitions = []\n    for cur_value in content:\n        name, type = get_table_partition_name_type(cur_value)\n        mode = get_table_partition_mode(cur_value)\n        source = get_table_partition_source(cur_value)\n        description = get_table_description(cur_value)\n        source_without_docs = remove_doc_comments(source) if source else None\n        partitions.append({\n            'name': name,\n            'type': type,\n            'mode': mode,\n            'raw_expression': source,\n            'expression': source_without_docs,\n            'description': description,\n        })\n    return partitions\n</code></pre>"},{"location":"reference/parse/tmdl/#pbipinspect.parse.tmdl.get_tmdl_relationship","title":"<code>get_tmdl_relationship(tmdl: str) -&gt; list[dict]</code>","text":"<p>Parse the relationships from a given TMDL content.</p> <p>Parameters:</p> <ul> <li> <code>tmdl</code>               (<code>str</code>)           \u2013            <p>The content of a TMDL file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[dict]</code>           \u2013            <p>A list of dictionaries, each one representing a relationship. Each dictionary has the following keys:     'name': str         The name of the relationship.     'fromTable': str         The name of the table from which the relationship starts.     'fromColumn': str         The name of the column from which the relationship starts.     'toTable': str         The name of the table to which the relationship ends.     'toColumn': str         The name of the column to which the relationship ends.     'crossFilteringBehavior': str         The cross filtering behavior of the relationship.         Can be 'oneDirection' or 'bothDirections'.     'filteringSymbol': str         The filtering symbol of the relationship.         Can be '&lt;' or '&lt;&gt;'.     'fromCardinalitySymbol': str         The cardinality symbol of the relationship.         Can be '1' or ''.     'toCardinalitySymbol': str         The cardinality symbol of the relationship.         Can be '1' or ''.     'isActive': bool         Whether the relationship is active or not.</p> </li> </ul> Source code in <code>pbipinspect/parse/tmdl.py</code> <pre><code>def get_tmdl_relationship(tmdl: str) -&gt; list[dict]:\n    \"\"\"\n    Parse the relationships from a given TMDL content.\n\n    Parameters\n    ----------\n    tmdl : str\n        The content of a TMDL file.\n\n    Returns\n    -------\n    list[dict]\n        A list of dictionaries, each one representing a relationship.\n        Each dictionary has the following keys:\n            'name': str\n                The name of the relationship.\n            'fromTable': str\n                The name of the table from which the relationship starts.\n            'fromColumn': str\n                The name of the column from which the relationship starts.\n            'toTable': str\n                The name of the table to which the relationship ends.\n            'toColumn': str\n                The name of the column to which the relationship ends.\n            'crossFilteringBehavior': str\n                The cross filtering behavior of the relationship.\n                Can be 'oneDirection' or 'bothDirections'.\n            'filteringSymbol': str\n                The filtering symbol of the relationship.\n                Can be '&lt;' or '&lt;&gt;'.\n            'fromCardinalitySymbol': str\n                The cardinality symbol of the relationship.\n                Can be '1' or '*'.\n            'toCardinalitySymbol': str\n                The cardinality symbol of the relationship.\n                Can be '1' or '*'.\n            'isActive': bool\n                Whether the relationship is active or not.\n    \"\"\"\n\n    splited = tmdl.split('relationship')[1:]\n    relationships = []\n    for x in splited:\n        filtering_behavior = get_relationship_cross_filtering_behavior(x)\n        from_cardinality = get_relationship_from_cardinality(x)\n        to_cardinality = get_relationship_to_cardinality(x)\n\n        filtering_cardinality = get_relationship_filter_cardinality(\n            filtering_behavior,\n            to_cardinality,\n            from_cardinality\n        )\n        filtering_symbol, from_cardinality_symbol, to_cardinality_symbol = filtering_cardinality\n\n        name = get_relationship_name(x)\n        from_table, from_column = get_relationship_from_column(x)\n        to_table, to_column = get_relationship_to_column(x)\n        cross_filtering_behavior = get_relationship_cross_filtering_behavior(x)\n        is_active = get_relationship_is_active(x)\n        relationships.append({\n            'name': name,\n            'fromTable': from_table,\n            'fromColumn': from_column,\n            'toTable': to_table,\n            'toColumn': to_column,\n            'crossFilteringBehavior': cross_filtering_behavior,\n            'filteringSymbol': filtering_symbol,\n            'fromCardinalitySymbol': from_cardinality_symbol,\n            'toCardinalitySymbol': to_cardinality_symbol,\n            'isActive': is_active\n        })\n    return relationships\n</code></pre>"},{"location":"reference/parse/tmdl/#pbipinspect.parse.tmdl.get_tmdl_table","title":"<code>get_tmdl_table(tmdl: str) -&gt; dict</code>","text":"<p>Reads a .tmdl file and returns a dictionary containing the table information</p> <p>Parameters:</p> <ul> <li> <code>tmdl</code>               (<code>str</code>)           \u2013            <p>The contents of the .tmdl file</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>A dictionary containing the table information with the following keys:     - name: The name of the table     - lineageTag: The lineage tag of the table     - isHidden: A boolean indicating if the table is hidden     - isPrivate: A boolean indicating if the table is private     - columns: A list of dictionaries containing the column information     - measures: A list of dictionaries containing the measure information     - partitions: A list of dictionaries containing the partition information</p> </li> </ul> Source code in <code>pbipinspect/parse/tmdl.py</code> <pre><code>def get_tmdl_table(tmdl: str) -&gt; dict:\n    \"\"\"\n    Reads a .tmdl file and returns a dictionary containing the table information\n\n    Parameters\n    ----------\n    tmdl : str\n        The contents of the .tmdl file\n\n    Returns\n    -------\n    dict\n        A dictionary containing the table information with the following keys:\n            - name: The name of the table\n            - lineageTag: The lineage tag of the table\n            - isHidden: A boolean indicating if the table is hidden\n            - isPrivate: A boolean indicating if the table is private\n            - columns: A list of dictionaries containing the column information\n            - measures: A list of dictionaries containing the measure information\n            - partitions: A list of dictionaries containing the partition information\n    \"\"\"\n    table_name = get_table_name(tmdl)\n    lineage_tag = get_table_lineage_tag(tmdl)\n    is_hidden = check_table_property(tmdl, 'isHidden')\n    is_private = check_table_property(tmdl, 'isPrivate')\n    table_columns = get_table_columns(tmdl)\n    table_measures = get_table_measures(tmdl)\n    table_partitions = get_table_partitions(tmdl)\n\n    expression = table_partitions[0]['raw_expression']\n    columns_with_descriptions = put_column_description(table_columns, expression)\n    return {\n        'name': table_name,\n        'lineageTag': lineage_tag,\n        'isHidden': is_hidden,\n        'isPrivate': is_private,\n        'columns': columns_with_descriptions,\n        'measures': table_measures,\n        'partitions': table_partitions\n    }\n</code></pre>"},{"location":"reference/parse/tmsl/","title":"tmsl","text":"<p>Functions:</p> <ul> <li> <code>clean_tmsl</code>             \u2013              <p>Clean the given TMSL model.</p> </li> <li> <code>clean_tmsl_columns</code>             \u2013              <p>Clean columns from the given TMSL model.</p> </li> <li> <code>clean_tmsl_expressions</code>             \u2013              <p>Clean expressions from the given TMSL model.</p> </li> <li> <code>clean_tmsl_measures</code>             \u2013              <p>Clean measures from the given TMSL model.</p> </li> <li> <code>clean_tmsl_partitions</code>             \u2013              <p>Clean the given list of partition dictionaries.</p> </li> <li> <code>clean_tmsl_relationships</code>             \u2013              <p>Clean relationships from the given TMSL model.</p> </li> <li> <code>clean_tmsl_tables</code>             \u2013              <p>Clean tables from the given TMSL model.</p> </li> </ul>"},{"location":"reference/parse/tmsl/#pbipinspect.parse.tmsl.clean_tmsl","title":"<code>clean_tmsl(tmsl_model: dict) -&gt; dict</code>","text":"<p>Clean the given TMSL model.</p> <p>Parameters:</p> <ul> <li> <code>tmsl_model</code>               (<code>dict</code>)           \u2013            <p>The TMSL model to clean.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>A cleaned version of the given TMSL model.</p> </li> </ul> Source code in <code>pbipinspect/parse/tmsl.py</code> <pre><code>def clean_tmsl(tmsl_model: dict) -&gt; dict:\n    \"\"\"\n    Clean the given TMSL model.\n\n    Parameters\n    ----------\n    tmsl_model : dict\n        The TMSL model to clean.\n\n    Returns\n    -------\n    dict\n        A cleaned version of the given TMSL model.\n    \"\"\"\n    model = tmsl_model['model']\n    tables = model.get('tables', [])\n    relationships = model.get('relationships', [])\n    expressions = model.get('expressions', [])\n    cleaned_tables = clean_tmsl_tables(tables)\n    cleaned_relationships = clean_tmsl_relationships(relationships)\n    cleaned_expressions = clean_tmsl_expressions(expressions)\n    new_model = {\n        'model': {\n            'tables': cleaned_tables,\n            'relationships': cleaned_relationships,\n            'expressions': cleaned_expressions\n        }\n    }\n    return new_model\n</code></pre>"},{"location":"reference/parse/tmsl/#pbipinspect.parse.tmsl.clean_tmsl_columns","title":"<code>clean_tmsl_columns(columns: list[dict]) -&gt; list[dict]</code>","text":"<p>Clean columns from the given TMSL model.</p> <p>Parameters:</p> <ul> <li> <code>columns</code>               (<code>list[dict]</code>)           \u2013            <p>The list of columns to clean</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[dict]</code>           \u2013            <p>A list of cleaned column dictionaries. The dictionaries have the following keys: - name: str - expression: str | None - isHidden: bool - isNameInferred: bool - dataType: str - lineageTag: str - summarizeBy: str - sourceColumn: str | None - annotations: list[str] | None - calculated: bool - description: str</p> </li> </ul> Source code in <code>pbipinspect/parse/tmsl.py</code> <pre><code>def clean_tmsl_columns(columns: list[dict]) -&gt; list[dict]:\n    \"\"\"\n    Clean columns from the given TMSL model.\n\n    Parameters\n    ----------\n    columns : list[dict]\n        The list of columns to clean\n\n    Returns\n    -------\n    list[dict]\n        A list of cleaned column dictionaries. The dictionaries have the following keys:\n        - name: str\n        - expression: str | None\n        - isHidden: bool\n        - isNameInferred: bool\n        - dataType: str\n        - lineageTag: str\n        - summarizeBy: str\n        - sourceColumn: str | None\n        - annotations: list[str] | None\n        - calculated: bool\n        - description: str\n    \"\"\"\n    cleaned: list[dict] = []\n    if not columns:\n        return cleaned\n    for column in columns:\n        cleaned.append({\n            'name': column['name'],\n            'expression': column.get('expression', ''),\n            'isHidden': column.get('isHidden', False),\n            'isNameInferred': column.get('isHidden', False),\n            'dataType': column['dataType'],\n            'lineageTag': column['lineageTag'],\n            'summarizeBy': column['summarizeBy'],\n            'sourceColumn': column.get('sourceColumn'),\n            'annotations': column.get('annotations'),\n            'calculated': str(column.get('sourceColumn')).startswith('[') or bool(column.get('expression')),\n            'description': column.get('description', '')\n        })\n    return cleaned\n</code></pre>"},{"location":"reference/parse/tmsl/#pbipinspect.parse.tmsl.clean_tmsl_expressions","title":"<code>clean_tmsl_expressions(expressions: list[dict]) -&gt; list[dict]</code>","text":"<p>Clean expressions from the given TMSL model.</p> <p>Parameters:</p> <ul> <li> <code>expressions</code>               (<code>list[dict]</code>)           \u2013            <p>The list of expressions to clean.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[dict]</code>           \u2013            <p>A list of cleaned expression dictionaries. Each dictionary contains the following keys: - name: str - expression: str - description: str</p> </li> </ul> Source code in <code>pbipinspect/parse/tmsl.py</code> <pre><code>def clean_tmsl_expressions(expressions: list[dict]) -&gt; list[dict]:\n    \"\"\"\n    Clean expressions from the given TMSL model.\n\n    Parameters\n    ----------\n    expressions : list[dict]\n        The list of expressions to clean.\n\n    Returns\n    -------\n    list[dict]\n        A list of cleaned expression dictionaries. Each dictionary contains the following keys:\n        - name: str\n        - expression: str\n        - description: str\n    \"\"\"\n    cleaned = []\n    for expression in expressions:\n        is_function = any([True for x in expression['annotations'] if x['value'] == 'Function'])\n        if not is_function:\n            expr = expression['expression'].split('meta')[0].strip()\n        else:\n            expr = '\\n'.join(expression['expression']).strip()\n        cleaned.append({\n            'name': expression['name'],\n            'lineageTag': expression['lineageTag'],\n            'expression': expr,\n            'description': expression.get('description'),\n            'type': 'function' if is_function else 'parameter'\n        })\n    return cleaned\n</code></pre>"},{"location":"reference/parse/tmsl/#pbipinspect.parse.tmsl.clean_tmsl_measures","title":"<code>clean_tmsl_measures(measures: list[dict]) -&gt; list[dict]</code>","text":"<p>Clean measures from the given TMSL model.</p> <p>Parameters:</p> <ul> <li> <code>measures</code>               (<code>list[dict]</code>)           \u2013            <p>The list of measures to clean.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[dict]</code>           \u2013            <p>A list of cleaned measure dictionaries. Each dictionary contains the following keys: - name: str - lineageTag: str - annotations: list[str] | None - displayFolder: str - expression: str - formatString: str | None - description: str - references: list[str]</p> </li> </ul> Source code in <code>pbipinspect/parse/tmsl.py</code> <pre><code>def clean_tmsl_measures(measures: list[dict]) -&gt; list[dict]:\n    \"\"\"\n    Clean measures from the given TMSL model.\n\n    Parameters\n    ----------\n    measures : list[dict]\n        The list of measures to clean.\n\n    Returns\n    -------\n    list[dict]\n        A list of cleaned measure dictionaries. Each dictionary contains the following keys:\n        - name: str\n        - lineageTag: str\n        - annotations: list[str] | None\n        - displayFolder: str\n        - expression: str\n        - formatString: str | None\n        - description: str\n        - references: list[str]\n    \"\"\"\n    cleaned: list[dict] = []\n    if not measures:\n        return cleaned\n    for measure in measures:\n        expression = measure['expression']\n        if isinstance(expression, str):\n            expression = [expression]\n        expression = '\\n'.join(expression).strip()\n        cleaned.append({\n            'name': measure['name'],\n            'lineageTag': measure['lineageTag'],\n            'annotations': measure.get('annotations'),\n            'displayFolder': measure.get('displayFolder', ''),\n            'expression': remove_doc_comments(expression),\n            'formatString': measure.get('formatString'),\n            'description': get_measure_description(expression),\n            'references': get_measure_references(expression)\n        })\n    return cleaned\n</code></pre>"},{"location":"reference/parse/tmsl/#pbipinspect.parse.tmsl.clean_tmsl_partitions","title":"<code>clean_tmsl_partitions(partitions: list[dict]) -&gt; list[dict]</code>","text":"<p>Clean the given list of partition dictionaries.</p> <p>Parameters:</p> <ul> <li> <code>partitions</code>               (<code>list[dict]</code>)           \u2013            <p>The list of partition dictionaries to clean</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[dict]</code>           \u2013            <p>A list of cleaned partition dictionaries. The dictionaries have the following keys: - name: str - type: str - mode: str - raw_expression: str - expression: str - description: str</p> </li> </ul> Source code in <code>pbipinspect/parse/tmsl.py</code> <pre><code>def clean_tmsl_partitions(partitions: list[dict]) -&gt; list[dict]:\n    \"\"\"\n    Clean the given list of partition dictionaries.\n\n    Parameters\n    ----------\n    partitions : list[dict]\n        The list of partition dictionaries to clean\n\n    Returns\n    -------\n    list[dict]\n        A list of cleaned partition dictionaries. The dictionaries have the following keys:\n        - name: str\n        - type: str\n        - mode: str\n        - raw_expression: str\n        - expression: str\n        - description: str\n    \"\"\"\n    cleaned = []\n    for partition in partitions:\n        expression = partition['source']['expression']\n        if isinstance(expression, str):\n            expression = [expression]\n        expression = '\\n'.join(expression).strip()\n        cleaned.append({\n            'name': partition['name'],\n            'type': partition['source']['type'],\n            'mode': partition['mode'],\n            'raw_expression': expression,\n            'expression': remove_doc_comments(expression),\n            'description': get_table_description(expression)\n        })\n    return cleaned\n</code></pre>"},{"location":"reference/parse/tmsl/#pbipinspect.parse.tmsl.clean_tmsl_relationships","title":"<code>clean_tmsl_relationships(relationships: list[dict]) -&gt; list[dict]</code>","text":"<p>Clean relationships from the given TMSL model.</p> <p>Parameters:</p> <ul> <li> <code>relationships</code>               (<code>list[dict]</code>)           \u2013            <p>The list of relationships to clean.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[dict]</code>           \u2013            <p>A list of cleaned relationship dictionaries. Each dictionary contains the following keys: - name: str - fromTable: str - fromColumn: str - toTable: str - toColumn: str - crossFilteringBehavior: str - filteringSymbol: str - fromCardinalitySymbol: str - toCardinalitySymbol: str - isActive: bool</p> </li> </ul> Source code in <code>pbipinspect/parse/tmsl.py</code> <pre><code>def clean_tmsl_relationships(relationships: list[dict]) -&gt; list[dict]:\n    \"\"\"\n    Clean relationships from the given TMSL model.\n\n    Parameters\n    ----------\n    relationships : list[dict]\n        The list of relationships to clean.\n\n    Returns\n    -------\n    list[dict]\n        A list of cleaned relationship dictionaries. Each dictionary contains the following keys:\n        - name: str\n        - fromTable: str\n        - fromColumn: str\n        - toTable: str\n        - toColumn: str\n        - crossFilteringBehavior: str\n        - filteringSymbol: str\n        - fromCardinalitySymbol: str\n        - toCardinalitySymbol: str\n        - isActive: bool\n    \"\"\"\n    cleaned = []\n    for relationship in relationships:\n        filtering_behavior = relationship.get('crossFilteringBehavior', 'singleDirection')\n        to_cardinality = relationship.get('toCardinality')\n        from_cardinality = relationship.get('fromCardinality')\n\n        filtering_cardinality = get_relationship_filter_cardinality(\n            filtering_behavior,\n            to_cardinality,\n            from_cardinality\n        )\n        filtering_symbol, from_cardinality_symbol, to_cardinality_symbol = filtering_cardinality\n\n        cleaned.append({\n            'name': relationship['name'],\n            'fromTable': relationship['fromTable'],\n            'fromColumn': relationship['fromColumn'],\n            'toTable': relationship['toTable'],\n            'toColumn': relationship['toColumn'],\n            'crossFilteringBehavior': filtering_behavior,\n            'filteringSymbol': filtering_symbol,\n            'fromCardinalitySymbol': from_cardinality_symbol,\n            'toCardinalitySymbol': to_cardinality_symbol,\n            'isActive': relationship.get('isActive', True)\n        })\n    return cleaned\n</code></pre>"},{"location":"reference/parse/tmsl/#pbipinspect.parse.tmsl.clean_tmsl_tables","title":"<code>clean_tmsl_tables(tables: list[dict]) -&gt; list[dict]</code>","text":"<p>Clean tables from the given TMSL model.</p> <p>Parameters:</p> <ul> <li> <code>tables</code>               (<code>list[dict]</code>)           \u2013            <p>The list of tables to clean.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[dict]</code>           \u2013            <p>A list of cleaned table dictionaries. Each dictionary contains the following keys: - name: str - lineageTag: str - isHidden: bool - isPrivate: bool - columns: list[dict] - measures: list[dict] - partitions: list[dict]</p> </li> </ul> Source code in <code>pbipinspect/parse/tmsl.py</code> <pre><code>def clean_tmsl_tables(tables: list[dict]) -&gt; list[dict]:\n    \"\"\"\n    Clean tables from the given TMSL model.\n\n    Parameters\n    ----------\n    tables : list[dict]\n        The list of tables to clean.\n\n    Returns\n    -------\n    list[dict]\n        A list of cleaned table dictionaries. Each dictionary contains the following keys:\n        - name: str\n        - lineageTag: str\n        - isHidden: bool\n        - isPrivate: bool\n        - columns: list[dict]\n        - measures: list[dict]\n        - partitions: list[dict]\n    \"\"\"\n    cleaned = []\n    for table in tables:\n        expression = table['partitions'][0]['source']['expression']\n        if isinstance(expression, str):\n            expression = [expression]\n        expression = '\\n'.join(expression).strip()\n        columns = table.get('columns', [])\n        columns_with_descriptions = put_column_description(columns, expression)\n\n        cleaned.append({\n            'name': table['name'],\n            'lineageTag': table['lineageTag'],\n            'isHidden': table.get('isHidden', False),\n            'isPrivate': table.get('isPrivate', False),\n            'columns': clean_tmsl_columns(columns_with_descriptions),\n            'measures': clean_tmsl_measures(table.get('measures', [])),\n            'partitions': clean_tmsl_partitions(table['partitions'])\n        })\n    return cleaned\n</code></pre>"},{"location":"reference/parse/utils/","title":"utils","text":"<p>Functions:</p> <ul> <li> <code>get_content_until_next_level</code>             \u2013              <p>Returns the content until the next level of indentation.</p> </li> <li> <code>get_measure_description</code>             \u2013              <p>Extracts the measure description from a given string.</p> </li> <li> <code>get_measure_references</code>             \u2013              <p>Extracts table column and measure references from a given expression.</p> </li> <li> <code>get_measure_references_measure</code>             \u2013              <p>Returns all measure references in a given measure expression.</p> </li> <li> <code>get_measure_references_table_column</code>             \u2013              <p>Returns all table column references in a given measure expression.</p> </li> <li> <code>get_relationship_filter_cardinality</code>             \u2013              <p>Returns a tuple of 3 strings that represent the filtering direction, and the</p> </li> <li> <code>get_table_column_description</code>             \u2013              <p>Extracts the column descriptions from a given string.</p> </li> <li> <code>get_table_description</code>             \u2013              <p>Extracts the table description from a given string.</p> </li> <li> <code>get_table_property_content</code>             \u2013              <p>Returns the content of a given table property from a TMDL file.</p> </li> <li> <code>put_column_description</code>             \u2013              <p>Adds column descriptions to a list of columns.</p> </li> <li> <code>remove_doc_comments</code>             \u2013              <p>Removes Power BI style doc comments from a string.</p> </li> </ul>"},{"location":"reference/parse/utils/#pbipinspect.parse.utils.get_content_until_next_level","title":"<code>get_content_until_next_level(content: list[str], level_identifier: str = '\\t') -&gt; list[str]</code>","text":"<p>Returns the content until the next level of indentation.</p> <p>Parameters:</p> <ul> <li> <code>content</code>               (<code>list[str]</code>)           \u2013            <p>The content to be processed.</p> </li> <li> <code>level_identifier</code>               (<code>str</code>, default:                   <code>'\\t'</code> )           \u2013            <p>The string used to identify the level of indentation. Defaults to '     '.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>The content until the next level of indentation.</p> </li> </ul> Source code in <code>pbipinspect/parse/utils.py</code> <pre><code>def get_content_until_next_level(\n    content: list[str],\n    level_identifier: str='\\t'\n) -&gt; list[str]:\n    \"\"\"\n    Returns the content until the next level of indentation.\n\n    Parameters\n    ----------\n    content : list[str]\n        The content to be processed.\n    level_identifier : str, optional\n        The string used to identify the level of indentation. Defaults to '\\t'.\n\n    Returns\n    -------\n    list[str]\n        The content until the next level of indentation.\n    \"\"\"\n    if not content:\n        return []\n    last = content[-1].split('\\n')\n    idx_next_level = [\n        idx for idx, x in enumerate(last)\n        if x.count(level_identifier) == 1\n    ]\n    if not idx_next_level:\n        return content[:-1] + ['\\n'.join(last)]\n    return content[:-1] + ['\\n'.join(last[0:idx_next_level[0]])]\n</code></pre>"},{"location":"reference/parse/utils/#pbipinspect.parse.utils.get_measure_description","title":"<code>get_measure_description(x: str) -&gt; str</code>","text":"<p>Extracts the measure description from a given string.</p> <p>This function takes a string and returns the measure description, if present.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>str</code>)           \u2013            <p>The string to extract the measure description from.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The extracted measure description, or an empty string if no description is present.</p> </li> </ul> Source code in <code>pbipinspect/parse/utils.py</code> <pre><code>def get_measure_description(x: str) -&gt; str:\n    \"\"\"\n    Extracts the measure description from a given string.\n\n    This function takes a string and returns the measure description, if present.\n\n    Parameters\n    ----------\n    x : str\n        The string to extract the measure description from.\n\n    Returns\n    -------\n    str\n        The extracted measure description, or an empty string if no description is present.\n    \"\"\"\n    pattern = r'/\\* @doc(.*?)\\*/'\n    description = re.search(pattern, x, flags=re.DOTALL)\n    if description is None:\n        return ''\n    return description.group(1).replace('\\t', '').strip()\n</code></pre>"},{"location":"reference/parse/utils/#pbipinspect.parse.utils.get_measure_references","title":"<code>get_measure_references(expression: str) -&gt; list[dict]</code>","text":"<p>Extracts table column and measure references from a given expression.</p> <p>This function analyzes a measure expression to identify references to table columns and other measures. It returns a list of dictionaries where each dictionary describes a reference, specifying whether it is a 'table' or a 'measure', along with the respective name and column information for table references.</p> <p>Parameters:</p> <ul> <li> <code>expression</code>               (<code>str</code>)           \u2013            <p>The measure expression to analyze for references.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[dict]</code>           \u2013            <p>A list of dictionaries representing the references found in the expression. Each dictionary contains: - 'type': 'table' or 'measure' - 'name': Name of the table or measure - 'column': Name of the column (only for table references)</p> </li> </ul> Source code in <code>pbipinspect/parse/utils.py</code> <pre><code>def get_measure_references(expression: str) -&gt; list[dict]:\n    \"\"\"\n    Extracts table column and measure references from a given expression.\n\n    This function analyzes a measure expression to identify references to\n    table columns and other measures. It returns a list of dictionaries\n    where each dictionary describes a reference, specifying whether it is\n    a 'table' or a 'measure', along with the respective name and column\n    information for table references.\n\n    Parameters\n    ----------\n    expression : str\n        The measure expression to analyze for references.\n\n    Returns\n    -------\n    list[dict]\n        A list of dictionaries representing the references found in the\n        expression. Each dictionary contains:\n        - 'type': 'table' or 'measure'\n        - 'name': Name of the table or measure\n        - 'column': Name of the column (only for table references)\n    \"\"\"\n    table_column = get_measure_references_table_column(expression)\n    measures = get_measure_references_measure(expression)\n\n    references = []\n    for tc in table_column:\n        table, column, _ = re.split('\\\\[|\\\\]', tc)\n        references.append({\n            'type': 'table',\n            'name': table,\n            'column': column\n        })\n\n    for m in measures:\n        references.append({\n            'type': 'measure',\n            'name': m\n        })\n    return references\n</code></pre>"},{"location":"reference/parse/utils/#pbipinspect.parse.utils.get_measure_references_measure","title":"<code>get_measure_references_measure(expression: str) -&gt; list[str]</code>","text":"<p>Returns all measure references in a given measure expression.</p> <p>The function returns all measure references found in a given measure expression. The measure references are returned as a list of strings, where each string represents a measure reference in the following format: measure_name.</p> <p>Parameters:</p> <ul> <li> <code>expression</code>               (<code>str</code>)           \u2013            <p>The measure expression to find the measure references in.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>The list of measure references found in the measure expression.</p> </li> </ul> Source code in <code>pbipinspect/parse/utils.py</code> <pre><code>def get_measure_references_measure(expression: str) -&gt; list[str]:\n    \"\"\"\n    Returns all measure references in a given measure expression.\n\n    The function returns all measure references found in a given measure expression.\n    The measure references are returned as a list of strings, where each string\n    represents a measure reference in the following format: measure_name.\n\n    Parameters\n    ----------\n    expression : str\n        The measure expression to find the measure references in.\n\n    Returns\n    -------\n    list[str]\n        The list of measure references found in the measure expression.\n    \"\"\"\n    pattern = r'(?&lt;![\\w\\'])\\[[^\\]]+\\](?!\\[\\w)'\n    matches = re.findall(pattern, expression)\n    unique_matches = list(set([m.replace('[', '').replace(']', '') for m in matches]))\n    return unique_matches\n</code></pre>"},{"location":"reference/parse/utils/#pbipinspect.parse.utils.get_measure_references_table_column","title":"<code>get_measure_references_table_column(expression: str) -&gt; list[str]</code>","text":"<p>Returns all table column references in a given measure expression.</p> <p>The function returns all table column references found in a given measure expression. The table column references are returned as a list of strings, where each string represents a table column reference in the following format: table_name[column_name].</p> <p>Parameters:</p> <ul> <li> <code>expression</code>               (<code>str</code>)           \u2013            <p>The measure expression to find the table column references in.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>The list of table column references found in the measure expression.</p> </li> </ul> Source code in <code>pbipinspect/parse/utils.py</code> <pre><code>def get_measure_references_table_column(expression: str) -&gt; list[str]:\n    \"\"\"\n    Returns all table column references in a given measure expression.\n\n    The function returns all table column references found in a given measure expression.\n    The table column references are returned as a list of strings, where each string\n    represents a table column reference in the following format: table_name[column_name].\n\n    Parameters\n    ----------\n    expression : str\n        The measure expression to find the table column references in.\n\n    Returns\n    -------\n    list[str]\n        The list of table column references found in the measure expression.\n    \"\"\"\n    pattern = r\"(?:\\b[a-zA-Z_][a-zA-Z0-9_]*\\[[^\\]]+\\])|(?:\\'[^\\']+\\'\\[[^\\]]+\\])\"\n    matches = re.findall(pattern, expression)\n    unique_matches = list(set(matches))\n    return unique_matches\n</code></pre>"},{"location":"reference/parse/utils/#pbipinspect.parse.utils.get_relationship_filter_cardinality","title":"<code>get_relationship_filter_cardinality(filtering: str, to_cardinality: str | None, from_cardinality: str | None) -&gt; tuple[str, str, str]</code>","text":"<p>Returns a tuple of 3 strings that represent the filtering direction, and the cardinality of the \"from\" and \"to\" columns in a relationship.</p> <p>Parameters:</p> <ul> <li> <code>filtering</code>               (<code>str</code>)           \u2013            <p>The filtering behavior of the relationship. Can be 'singleDirection' or 'bothDirections'.</p> </li> <li> <code>to_cardinality</code>               (<code>str | None</code>)           \u2013            <p>The cardinality of the \"to\" column in the relationship. Can be 'one' or 'many', or None.</p> </li> <li> <code>from_cardinality</code>               (<code>str | None</code>)           \u2013            <p>The cardinality of the \"from\" column in the relationship. Can be 'one' or 'many', or None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[str, str, str]</code>           \u2013            <p>A tuple of 3 strings. The first element is the filtering direction symbol, the second element is the \"from\" column cardinality symbol, and the third element is the \"to\" column cardinality symbol. The filtering direction symbol is '&lt;' for single direction and '&lt;&gt;' for both directions. The cardinality symbols are '1' for one-to-one and '*' for one-to-many or many-to-many.</p> </li> </ul> Source code in <code>pbipinspect/parse/utils.py</code> <pre><code>def get_relationship_filter_cardinality(\n    filtering: str,\n    to_cardinality: str | None,\n    from_cardinality: str | None,\n) -&gt; tuple[str, str, str]:\n    \"\"\"\n    Returns a tuple of 3 strings that represent the filtering direction, and the\n    cardinality of the \"from\" and \"to\" columns in a relationship.\n\n    Parameters\n    ----------\n    filtering : str\n        The filtering behavior of the relationship. Can be 'singleDirection' or\n        'bothDirections'.\n    to_cardinality : str | None\n        The cardinality of the \"to\" column in the relationship. Can be 'one' or\n        'many', or None.\n    from_cardinality : str | None\n        The cardinality of the \"from\" column in the relationship. Can be 'one' or\n        'many', or None.\n\n    Returns\n    -------\n    tuple[str, str, str]\n        A tuple of 3 strings. The first element is the filtering direction\n        symbol, the second element is the \"from\" column cardinality symbol, and\n        the third element is the \"to\" column cardinality symbol. The filtering\n        direction symbol is '&lt;' for single direction and '&lt;&gt;' for both\n        directions. The cardinality symbols are '1' for one-to-one and '*' for\n        one-to-many or many-to-many.\n    \"\"\"\n    filtering_symbol = '&lt;' if filtering == 'singleDirection' else '&lt;&gt;'\n    from_cardinality_symbol = '*'\n    to_cardinality_symbol = '*'\n\n    if filtering == 'bothDirections':\n        if from_cardinality == 'one' or to_cardinality == 'one':\n            from_cardinality_symbol = '1'\n            to_cardinality_symbol = '1'\n        elif not from_cardinality and not to_cardinality:\n            to_cardinality_symbol = '1'\n        elif to_cardinality == 'oneToMany':\n            to_cardinality_symbol = '1'\n\n    elif filtering == 'singleDirection':\n        if not to_cardinality:\n            to_cardinality_symbol = '1'\n        elif to_cardinality == 'many':\n            from_cardinality_symbol = '*'\n            to_cardinality_symbol = '*'\n        elif to_cardinality == 'oneToMany':\n            from_cardinality_symbol = '*'\n            to_cardinality_symbol = '1'\n\n    return (filtering_symbol, from_cardinality_symbol, to_cardinality_symbol)\n</code></pre>"},{"location":"reference/parse/utils/#pbipinspect.parse.utils.get_table_column_description","title":"<code>get_table_column_description(x: str) -&gt; dict[str, str]</code>","text":"<p>Extracts the column descriptions from a given string.</p> <p>This function takes a string and returns a dictionary with the column names as keys and their descriptions as values. The descriptions are the text that follows the '@col' tag until the '@col' or '*/' tag or the end of the string.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>str</code>)           \u2013            <p>The string to extract the column descriptions from.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, str]</code>           \u2013            <p>A dictionary with the column names as keys and their descriptions as values.</p> </li> </ul> Source code in <code>pbipinspect/parse/utils.py</code> <pre><code>def get_table_column_description(x: str) -&gt; dict[str, str]:\n    \"\"\"\n    Extracts the column descriptions from a given string.\n\n    This function takes a string and returns a dictionary with the column names as\n    keys and their descriptions as values. The descriptions are the text that follows\n    the '@col' tag until the '@col' or '*/' tag or the end of the string.\n\n    Parameters\n    ----------\n    x : str\n        The string to extract the column descriptions from.\n\n    Returns\n    -------\n    dict[str, str]\n        A dictionary with the column names as keys and their descriptions as values.\n    \"\"\"\n    pattern = r'@col\\s+(\\w+):\\s+(.*?)(?=@col|\\*\\/)'\n    matches = re.findall(pattern, x, re.DOTALL)\n    result = {match[0]: match[1].strip() for match in matches}\n    return result\n</code></pre>"},{"location":"reference/parse/utils/#pbipinspect.parse.utils.get_table_description","title":"<code>get_table_description(x: str, pattern='@doc\\\\s+(.*?)(?=@col|$)') -&gt; str</code>","text":"<p>Extracts the table description from a given string.</p> <p>This function takes a string and returns the table description, if present. The table description is the text that follows the '@doc' tag until the '@col' tag or the end of the string.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>str</code>)           \u2013            <p>The string to extract the table description from.</p> </li> <li> <code>pattern</code>               (<code>str</code>, default:                   <code>'@doc\\\\s+(.*?)(?=@col|$)'</code> )           \u2013            <p>The regular expression pattern to match the table description.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The extracted table description, or an empty string if no description is present.</p> </li> </ul> Source code in <code>pbipinspect/parse/utils.py</code> <pre><code>def get_table_description(x: str, pattern = r'@doc\\s+(.*?)(?=@col|$)') -&gt; str:\n    \"\"\"\n    Extracts the table description from a given string.\n\n    This function takes a string and returns the table description, if present.\n    The table description is the text that follows the '@doc' tag until the\n    '@col' tag or the end of the string.\n\n    Parameters\n    ----------\n    x : str\n        The string to extract the table description from.\n    pattern : str, optional\n        The regular expression pattern to match the table description.\n\n    Returns\n    -------\n    str\n        The extracted table description, or an empty string if no description is present.\n    \"\"\"\n    description = re.search(pattern, x, flags=re.DOTALL)\n    if description is None:\n        return ''\n    return description.group(1).replace('\\t', '').strip()\n</code></pre>"},{"location":"reference/parse/utils/#pbipinspect.parse.utils.get_table_property_content","title":"<code>get_table_property_content(tmdl: str, property: str, level_identifier: str = '\\t') -&gt; list[str]</code>","text":"<p>Returns the content of a given table property from a TMDL file.</p> <p>Parameters:</p> <ul> <li> <code>tmdl</code>               (<code>str</code>)           \u2013            <p>The content of the TMDL file.</p> </li> <li> <code>property</code>               (<code>str</code>)           \u2013            <p>The name of the property to be extracted. Can be 'column', 'measure', or 'partition'.</p> </li> <li> <code>level_identifier</code>               (<code>str</code>, default:                   <code>'\\t'</code> )           \u2013            <p>The string used to identify the level of indentation. Defaults to '     '.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>The content of the given table property.</p> </li> </ul> Source code in <code>pbipinspect/parse/utils.py</code> <pre><code>def get_table_property_content(\n    tmdl: str, \n    property: str, \n    level_identifier: str='\\t'\n) -&gt; list[str]:\n    \"\"\"\n    Returns the content of a given table property from a TMDL file.\n\n    Parameters\n    ----------\n    tmdl : str\n        The content of the TMDL file.\n    property : str\n        The name of the property to be extracted. Can be 'column', 'measure', or\n        'partition'.\n    level_identifier : str, optional\n        The string used to identify the level of indentation. Defaults to '\\t'.\n\n    Returns\n    -------\n    list[str]\n        The content of the given table property.\n    \"\"\"\n    content = tmdl.split(f'{level_identifier}{property} ')[1:]\n    valid_content = get_content_until_next_level(content)\n    return valid_content\n</code></pre>"},{"location":"reference/parse/utils/#pbipinspect.parse.utils.put_column_description","title":"<code>put_column_description(columns: list[dict], table_expression: str) -&gt; list[dict]</code>","text":"<p>Adds column descriptions to a list of columns.</p> <p>This function takes a list of columns and a table expression, extracts the column descriptions from the table expression, and adds them to the columns.</p> <p>Parameters:</p> <ul> <li> <code>columns</code>               (<code>list[dict]</code>)           \u2013            <p>The list of columns to add descriptions to.</p> </li> <li> <code>table_expression</code>               (<code>str</code>)           \u2013            <p>The table expression to extract the column descriptions from.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[dict]</code>           \u2013            <p>The list of columns with descriptions added.</p> </li> </ul> Source code in <code>pbipinspect/parse/utils.py</code> <pre><code>def put_column_description(\n    columns: list[dict],\n    table_expression: str\n) -&gt; list[dict]:\n    \"\"\"\n    Adds column descriptions to a list of columns.\n\n    This function takes a list of columns and a table expression, extracts the column\n    descriptions from the table expression, and adds them to the columns.\n\n    Parameters\n    ----------\n    columns : list[dict]\n        The list of columns to add descriptions to.\n    table_expression : str\n        The table expression to extract the column descriptions from.\n\n    Returns\n    -------\n    list[dict]\n        The list of columns with descriptions added.\n    \"\"\"\n    cur_columns = deepcopy(columns)\n    columns_description = get_table_column_description(table_expression)\n    if columns:\n        for column in cur_columns:\n            column_name = column['name']\n            if column_name in columns_description:\n                column['description'] = columns_description[column_name]\n            else:\n                column['description'] = ''\n    return cur_columns\n</code></pre>"},{"location":"reference/parse/utils/#pbipinspect.parse.utils.remove_doc_comments","title":"<code>remove_doc_comments(x: str) -&gt; str</code>","text":"<p>Removes Power BI style doc comments from a string.</p> <p>The function removes all occurrences of / @doc / comments from a given string.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>str</code>)           \u2013            <p>The string to remove the doc comments from.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The string with the doc comments removed.</p> </li> </ul> Source code in <code>pbipinspect/parse/utils.py</code> <pre><code>def remove_doc_comments(x: str) -&gt; str:\n    \"\"\"Removes Power BI style doc comments from a string.\n\n    The function removes all occurrences of /* @doc */ comments from a given string.\n\n    Parameters\n    ----------\n    x : str\n        The string to remove the doc comments from.\n\n    Returns\n    -------\n    str\n        The string with the doc comments removed.\n    \"\"\"\n    pattern = r'/\\*\\s?@doc.*?\\*/'\n    return re.sub(pattern, '', x, flags=re.DOTALL).strip()\n</code></pre>"}]}