{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pbipinspect","text":"<p>Parse, validate and document your Power BI Project</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pbipinspect\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>This library brings your Power BI project to a structured and validated state. It provides a set of tools to analyze, validate, and document your project.</p> <p>First, you need to create a inspect. The <code>create_inspect</code> function takes a path to your project and returns a <code>PbipInspect</code> object. You can create directly with <code>PbipInspect</code> class, but <code>create_inspect</code> is recommended.</p> <pre><code>&gt;&gt;&gt; from pbipinspect import create_inspect\n&gt;&gt;&gt; inspect = create_inspect('your-project.pbip')\n</code></pre> <p>Inspect parse you Power BI Project and gives you the ability to validate and document it. You can see the model generated from your project acessing the attribute <code>model</code>. <pre><code>&gt;&gt;&gt; print(inspect.model)\n{'model': {\n    'tables': [{\n        'name': 'table',\n        'lineageTag': 'id',\n        'columns': [{...}],\n        'measures': [{...}],\n        'partitions': [{...}],\n        'isHidden': False,\n        'annotations': [{...}]\n    }],\n    'relationships': [{...}]\n}}\n</code></pre></p> <p>Now, it's possible to validate your project. This is possible thanks to expects. Pbipinspect already comes with some expects that you can use to validate your project.</p> <pre><code>&gt;&gt;&gt; from pbipinspect.expectations import *\n&gt;&gt;&gt; inspect.expectations(steps=[\n...     expect_col_starts_with(col_type='dateTime', pattern='dt_', state='Info'),\n...     expect_measure_starts_with(pattern='m_'),\n...     expect_table_starts_with(pattern='t_'),\n...     expect_table_name_no_spaces(),\n...     expect_cols_in_relationship_has_same_type(),\n...     expect_dax_lines_length(max_length=60),\n...     expect_m_lines_length(max_length=60),\n...     expect_measures_in_specific_table('_measures'),\n...     expect_no_calculated_columns(state='Error'),\n...     expect_all_relationships_active()\n&gt;&gt;&gt; ])\n&gt;&gt;&gt; inspect.run_expectations()\n&gt;&gt;&gt; print(inspect.expects)\n[{'expect': 'expect_col_starts_with',\n   'state': 'Warning',\n   'message': \"Column 'Column1' in table 'Table1' must start with 'dt_'\"},\n {'expect': 'expect_no_calculated_columns',\n  'state': 'Error',\n  'message': \"Table 'Table1' has calculated columns: 'Column2' and 'Column3'\"}\n]\n</code></pre>"},{"location":"#getting-help","title":"Getting help","text":"<p>If you encounter a clear bug, please file an issue with a minimal reproducible example on GitHub.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#010-2024-12-13","title":"[0.1.0] - 2024-12-13","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Expectations to validate Power BI project</li> <li>tmsl and tmdl parser</li> <li><code>Pbip</code> and <code>PbipInspect</code> class</li> <li><code>create_inspect</code> function to create a <code>PbipInspect</code></li> </ul>"},{"location":"license/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2024 Matheus S. Rodrigues</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"reference/expectations/","title":"expectations","text":"<p>Functions:</p> <ul> <li> <code>expect_all_relationships_active</code>             \u2013              <p>Returns a function that checks if all relationships in a Pbip object are active.</p> </li> <li> <code>expect_col_starts_with</code>             \u2013              <p>Returns a function that checks if columns in a Pbip object start</p> </li> <li> <code>expect_cols_in_relationship_has_same_type</code>             \u2013              <p>Returns a function that checks if columns in relationships of a Pbip object have the same type.</p> </li> <li> <code>expect_dax_lines_length</code>             \u2013              <p>Returns a function that checks if DAX measures in a Pbip object do not exceed the specified maximum length.</p> </li> <li> <code>expect_m_lines_length</code>             \u2013              <p>Returns a function that checks if M language expressions in the partitions</p> </li> <li> <code>expect_measure_starts_with</code>             \u2013              <p>Returns a function that checks if measures in a Pbip object start</p> </li> <li> <code>expect_measures_in_specific_table</code>             \u2013              <p>Returns a function that checks if measures in a Pbip object are in a specific table.</p> </li> <li> <code>expect_no_calculated_columns</code>             \u2013              <p>Returns a function that checks if calculated columns are not present in any table of a Pbip object.</p> </li> <li> <code>expect_table_name_no_spaces</code>             \u2013              <p>Returns a function that checks if table names in a Pbip object do not contain spaces.</p> </li> <li> <code>expect_table_starts_with</code>             \u2013              <p>Returns a function that checks if table names in a Pbip object start</p> </li> </ul>"},{"location":"reference/expectations/#pbipinspect.expectations.expect_all_relationships_active","title":"<code>expect_all_relationships_active(state: ExpectState = 'Warning') -&gt; Callable</code>","text":"<p>Returns a function that checks if all relationships in a Pbip object are active.</p> <p>Parameters:</p> <ul> <li> <code>state</code>               (<code>ExpectState</code>, default:                   <code>'Warning'</code> )           \u2013            <p>The state of the expectation, defaults to 'Warning'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>A function that checks if all relationships in a Pbip object are active.</p> </li> </ul> Source code in <code>pbipinspect/expectations.py</code> <pre><code>def expect_all_relationships_active(\n    state: ExpectState = 'Warning'\n) -&gt; Callable:\n    \"\"\"\n    Returns a function that checks if all relationships in a Pbip object are active.\n\n    Parameters\n    ----------\n    state : ExpectState, optional\n        The state of the expectation, defaults to 'Warning'.\n\n    Returns\n    -------\n    Callable\n        A function that checks if all relationships in a Pbip object are active.\n    \"\"\"\n\n    def function(pbip: Pbip) -&gt; list[ExpectMessage]:\n        relationships = pbip.relationships\n        if not relationships:\n            return []\n        checks = []\n        for relationship in relationships:\n            from_table = relationship['fromTable']\n            to_table = relationship['toTable']\n            from_column = relationship['fromColumn']\n            to_column = relationship['toColumn']\n            if not relationship['isActive']:\n                checks.append({\n                    'expect': 'expect_all_relationships_active',\n                    'state': state,\n                    'message': (f\"Relationship between '{from_table}.{from_column}' and '{to_table}.{to_column}' must be active.\"),\n                })\n        return checks\n    return function\n</code></pre>"},{"location":"reference/expectations/#pbipinspect.expectations.expect_col_starts_with","title":"<code>expect_col_starts_with(pattern: str, col_type: list[ColTypes] | ColTypes | None, state: ExpectState = 'Warning') -&gt; Callable</code>","text":"<p>Returns a function that checks if columns in a Pbip object start with the specified pattern and have a supported data type.</p> <p>Parameters:</p> <ul> <li> <code>pattern</code>               (<code>str</code>)           \u2013            <p>The pattern to match against the column name.</p> </li> <li> <code>col_type</code>               (<code>list[ColTypes] | ColTypes | None</code>)           \u2013            <p>The data type(s) to check for.</p> </li> <li> <code>state</code>               (<code>ExpectState</code>, default:                   <code>'Warning'</code> )           \u2013            <p>The state of the expectation, defaults to 'Warning'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>A function that checks if columns in a Pbip object start with the specified pattern and have a supported data type.</p> </li> </ul> Source code in <code>pbipinspect/expectations.py</code> <pre><code>def expect_col_starts_with(\n    pattern: str, \n    col_type: list[ColTypes] | ColTypes | None,\n    state: ExpectState = 'Warning'\n) -&gt; Callable:\n    \"\"\"\n    Returns a function that checks if columns in a Pbip object start\n    with the specified pattern and have a supported data type.\n\n    Parameters\n    ----------\n    pattern : str\n        The pattern to match against the column name.\n    col_type : list[ColTypes] | ColTypes | None\n        The data type(s) to check for.\n    state : ExpectState, optional\n        The state of the expectation, defaults to 'Warning'.\n\n    Returns\n    -------\n    Callable\n        A function that checks if columns in a Pbip object start\n        with the specified pattern and have a supported data type.\n    \"\"\"\n    not_supported = ['binary', 'list', 'record', 'time', 'percentage', 'duration'] \n\n    if col_type and not isinstance(col_type, list):\n        col_type = [col_type]\n\n    if col_type:\n        for col in col_type:\n            if col in not_supported:\n                Warning(f\"Col type '{col}' is not supported. I'll ignore this type.\")\n        col_type = [x for x in col_type if x not in not_supported]\n\n    def function(pbip: Pbip) -&gt; list[ExpectMessage]:\n        \"\"\"\n        Checks if columns in each table of the Pbip object start with a specified pattern\n        and match any of the specified data types.\n\n        Args:\n            pbip (Pbip): The Pbip object containing tables and columns to check.\n\n        Returns:\n            list[ExpectMessage]: A list of messages detailing any columns that do not meet the criteria.\n        \"\"\"\n        tables = pbip.tables\n        checks = []\n        for table in tables:\n            table_name = table['name']\n            cols = pbip.get_table_field(table_name, 'columns')\n            if not cols:\n                continue\n            for col in cols:\n                col_name = col['name']\n                check_type = col_type is None or col['dataType'] in col_type\n                if check_type and not col_name.startswith(pattern):\n                    checks.append({\n                        'expect': 'expect_col_starts_with',\n                        'state': state,\n                        'message': f\"Column '{col_name}' in table '{table_name}' must start with '{pattern}'\"\n                    })\n        return checks\n\n    return function\n</code></pre>"},{"location":"reference/expectations/#pbipinspect.expectations.expect_cols_in_relationship_has_same_type","title":"<code>expect_cols_in_relationship_has_same_type(state: ExpectState = 'Warning') -&gt; Callable</code>","text":"<p>Returns a function that checks if columns in relationships of a Pbip object have the same type.</p> <p>Parameters:</p> <ul> <li> <code>state</code>               (<code>ExpectState</code>, default:                   <code>'Warning'</code> )           \u2013            <p>The state of the expectation, defaults to 'Warning'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>A function that checks if columns in relationships of a Pbip object have the same type.</p> </li> </ul> Source code in <code>pbipinspect/expectations.py</code> <pre><code>def expect_cols_in_relationship_has_same_type(\n    state: ExpectState = 'Warning'\n) -&gt; Callable:\n    \"\"\"\n    Returns a function that checks if columns in relationships of a Pbip object have the same type.\n\n    Parameters\n    ----------\n    state : ExpectState, optional\n        The state of the expectation, defaults to 'Warning'.\n\n    Returns\n    -------\n    Callable\n        A function that checks if columns in relationships of a Pbip object have the same type.\n    \"\"\"\n    def function(pbip: Pbip) -&gt; list[ExpectMessage]:\n        checks = []\n        relationships = pbip.relationships\n        for relationship in relationships:\n            from_column = relationship['fromColumn']\n            from_table = relationship['fromTable']\n            to_column = relationship['toColumn']\n            to_table = relationship['toTable']\n\n            from_table_column = pbip.get_table_column(from_table, from_column)\n            to_table_column = pbip.get_table_column(to_table, to_column)\n\n            if from_table_column and to_table_column:\n                from_column_type = from_table_column['dataType']\n                to_column_type = to_table_column['dataType']\n\n                if from_column_type != to_column_type:\n                    checks.append({\n                        'expect': 'expect_cols_in_relationship_has_same_type',\n                        'state': state,\n                        'message': dedent(f\"\"\"\n                            Column '{from_column}' in table '{from_table}' and '{to_column}' in table '{to_table}' must have the same type.\n                            But I found '{from_column}' with '{from_column_type}' type and '{to_column}' with '{to_column_type}' type.\n                        \"\"\").strip()\n                    })\n        return checks\n    return function\n</code></pre>"},{"location":"reference/expectations/#pbipinspect.expectations.expect_dax_lines_length","title":"<code>expect_dax_lines_length(max_length: int, state: ExpectState = 'Warning') -&gt; Callable</code>","text":"<p>Returns a function that checks if DAX measures in a Pbip object do not exceed the specified maximum length.</p> <p>Parameters:</p> <ul> <li> <code>max_length</code>               (<code>int</code>)           \u2013            <p>The maximum length of a DAX measure.</p> </li> <li> <code>state</code>               (<code>ExpectState</code>, default:                   <code>'Warning'</code> )           \u2013            <p>The state of the expectation, defaults to 'Warning'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>A function that checks if DAX measures in a Pbip object do not exceed the specified maximum length.</p> </li> </ul> Source code in <code>pbipinspect/expectations.py</code> <pre><code>def expect_dax_lines_length(\n    max_length: int,\n    state: ExpectState = 'Warning'\n) -&gt; Callable:\n    \"\"\"\n    Returns a function that checks if DAX measures in a Pbip object do not exceed the specified maximum length.\n\n    Parameters\n    ----------\n    max_length : int\n        The maximum length of a DAX measure.\n    state : ExpectState, optional\n        The state of the expectation, defaults to 'Warning'.\n\n    Returns\n    -------\n    Callable\n        A function that checks if DAX measures in a Pbip object do not exceed the specified maximum length.\n    \"\"\"\n    def function(pbip: Pbip) -&gt; list[ExpectMessage]:\n        tables = pbip.tables\n        checks = []\n        for table in tables:\n            table_name = table['name']\n            measures = pbip.get_table_field(table_name, 'measures')\n            if not measures:\n                continue\n            for measure in measures:\n                measure_name = measure['name']\n                expression = measure['expression']\n                lines = check_lines_max_length(expression, max_length)\n                text = smart_join([x[0] for x in lines])\n                if any([x[1] for x in lines]):\n                    checks.append({\n                        'expect': 'expect_dax_lines_length',\n                        'state': state,\n                        'message': f\"Measure '{measure_name}' in table '{table_name}' has line(s) {text} longer than {max_length} characters\",\n                    })\n        return checks\n    return function\n</code></pre>"},{"location":"reference/expectations/#pbipinspect.expectations.expect_m_lines_length","title":"<code>expect_m_lines_length(max_length: int, state: ExpectState = 'Warning') -&gt; Callable</code>","text":"<p>Returns a function that checks if M language expressions in the partitions of tables within a Pbip object do not exceed the specified maximum length.</p> <p>Parameters:</p> <ul> <li> <code>max_length</code>               (<code>int</code>)           \u2013            <p>The maximum length of a line in an M language expression.</p> </li> <li> <code>state</code>               (<code>ExpectState</code>, default:                   <code>'Warning'</code> )           \u2013            <p>The state of the expectation, defaults to 'Warning'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>A function that checks if M language expressions in the partitions of tables within a Pbip object do not exceed the specified maximum length.</p> </li> </ul> Source code in <code>pbipinspect/expectations.py</code> <pre><code>def expect_m_lines_length(\n    max_length: int,\n    state: ExpectState = 'Warning'\n) -&gt; Callable:\n    \"\"\"\n    Returns a function that checks if M language expressions in the partitions\n    of tables within a Pbip object do not exceed the specified maximum length.\n\n    Parameters\n    ----------\n    max_length : int\n        The maximum length of a line in an M language expression.\n    state : ExpectState, optional\n        The state of the expectation, defaults to 'Warning'.\n\n    Returns\n    -------\n    Callable\n        A function that checks if M language expressions in the partitions\n        of tables within a Pbip object do not exceed the specified maximum length.\n    \"\"\"\n    def function(pbip: Pbip) -&gt; list[ExpectMessage]:\n        tables = pbip.tables\n        checks = []\n        for table in tables:\n            table_name = table['name']\n            partitions = pbip.get_table_field(table_name, 'partitions')\n            if not partitions:\n                continue\n            for partition in partitions:\n                expression = partition['expression']\n                lines = check_lines_max_length(expression, max_length)\n                text = text = smart_join([x[0] for x in lines])\n                if any([x[1] for x in lines]):\n                    checks.append({\n                        'expect': 'expect_m_lines_length',\n                        'state': state,\n                        'message': f\"Source code of table '{table_name}' has line(s) {text} longer than {max_length} characters\",\n                    })\n        return checks\n    return function\n</code></pre>"},{"location":"reference/expectations/#pbipinspect.expectations.expect_measure_starts_with","title":"<code>expect_measure_starts_with(pattern: str, state: ExpectState = 'Warning') -&gt; Callable</code>","text":"<p>Returns a function that checks if measures in a Pbip object start with the specified pattern.</p> <p>Parameters:</p> <ul> <li> <code>pattern</code>               (<code>str</code>)           \u2013            <p>The pattern to match against the measure name.</p> </li> <li> <code>state</code>               (<code>ExpectState</code>, default:                   <code>'Warning'</code> )           \u2013            <p>The state of the expectation, defaults to 'Warning'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>A function that checks if measures in a Pbip object start with the specified pattern.</p> </li> </ul> Source code in <code>pbipinspect/expectations.py</code> <pre><code>def expect_measure_starts_with(\n    pattern: str, \n    state: ExpectState = 'Warning'\n) -&gt; Callable:\n    \"\"\"\n    Returns a function that checks if measures in a Pbip object start\n    with the specified pattern.\n\n    Parameters\n    ----------\n    pattern : str\n        The pattern to match against the measure name.\n    state : ExpectState, optional\n        The state of the expectation, defaults to 'Warning'.\n\n    Returns\n    -------\n    Callable\n        A function that checks if measures in a Pbip object start\n        with the specified pattern.\n    \"\"\"\n\n    def function(pbip: Pbip) -&gt; list[ExpectMessage]:\n        tables = pbip.tables\n        checks = []\n        for table in tables:\n            table_name = table['name']\n            measures = pbip.get_table_field(table_name, 'measures')\n            if not measures:\n                continue\n            for measure in measures:\n                measure_name = measure['name']\n                if not measure_name.startswith(pattern):\n                    checks.append({\n                        'expect': 'expect_measure_starts_with',\n                        'state': state,\n                        'message': f\"Measure '{measure_name}' in table '{table_name}' must start with '{pattern}'\",\n                    })\n        return checks\n    return function\n</code></pre>"},{"location":"reference/expectations/#pbipinspect.expectations.expect_measures_in_specific_table","title":"<code>expect_measures_in_specific_table(table_name: str, state: ExpectState = 'Warning') -&gt; Callable</code>","text":"<p>Returns a function that checks if measures in a Pbip object are in a specific table.</p> <p>Parameters:</p> <ul> <li> <code>table_name</code>               (<code>str</code>)           \u2013            <p>The name of the table where measures should be.</p> </li> <li> <code>state</code>               (<code>ExpectState</code>, default:                   <code>'Warning'</code> )           \u2013            <p>The state of the expectation, defaults to 'Warning'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>A function that checks if measures in a Pbip object are in a specific table.</p> </li> </ul> Source code in <code>pbipinspect/expectations.py</code> <pre><code>def expect_measures_in_specific_table(\n    table_name: str,\n    state: ExpectState = 'Warning'\n) -&gt; Callable:\n    \"\"\"\n    Returns a function that checks if measures in a Pbip object are in a specific table.\n\n    Parameters\n    ----------\n    table_name : str\n        The name of the table where measures should be.\n    state : ExpectState, optional\n        The state of the expectation, defaults to 'Warning'.\n\n    Returns\n    -------\n    Callable\n        A function that checks if measures in a Pbip object are in a specific table.\n    \"\"\"\n    def function(pbip: Pbip) -&gt; list[ExpectMessage]:\n        tables = pbip.tables\n        checks = []\n        tables_with_measures = []\n        for table in tables:\n            measures = pbip.get_table_field(table['name'], 'measures')\n            if measures:\n                tables_with_measures.append(table['name'])\n        invalid_tables = [\n            table\n            for table in tables_with_measures\n            if table != table_name\n        ]\n        if invalid_tables:\n            checks.append({\n                'expect': 'expect_measures_in_specific_table',\n                'state': state,\n                'message': f\"Measures must be in table '{table_name}' but found in table(s) {smart_join(invalid_tables)}\",\n            })\n        return checks\n    return function\n</code></pre>"},{"location":"reference/expectations/#pbipinspect.expectations.expect_no_calculated_columns","title":"<code>expect_no_calculated_columns(state: ExpectState = 'Warning') -&gt; Callable</code>","text":"<p>Returns a function that checks if calculated columns are not present in any table of a Pbip object.</p> <p>Parameters:</p> <ul> <li> <code>state</code>               (<code>ExpectState</code>, default:                   <code>'Warning'</code> )           \u2013            <p>The state of the expectation, defaults to 'Warning'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>A function that checks if calculated columns are not present in any table of a Pbip object.</p> </li> </ul> Source code in <code>pbipinspect/expectations.py</code> <pre><code>def expect_no_calculated_columns(\n    state: ExpectState = 'Warning'\n) -&gt; Callable:\n    \"\"\"\n    Returns a function that checks if calculated columns are not present in any table of a Pbip object.\n\n    Parameters\n    ----------\n    state : ExpectState, optional\n        The state of the expectation, defaults to 'Warning'.\n\n    Returns\n    -------\n    Callable\n        A function that checks if calculated columns are not present in any table of a Pbip object.\n    \"\"\"\n    def function(pbip: Pbip) -&gt; list[ExpectMessage]:\n        tables = pbip.tables\n        checks = []\n        for table in tables:\n            columns = []\n            table_name = table['name']\n            table_columns = pbip.get_table_field(table_name, 'columns')\n            if table_columns is None:\n                continue\n            for column in table_columns:\n                if column['calculated']:\n                    columns.append(column['name'])\n            if columns:\n                checks.append({\n                    'expect': 'expect_no_calculated_columns',\n                    'state': state,\n                    'message': f\"Table '{table_name}' has calculated columns: {smart_join(columns)}\",\n                })\n        return checks\n    return function\n</code></pre>"},{"location":"reference/expectations/#pbipinspect.expectations.expect_table_name_no_spaces","title":"<code>expect_table_name_no_spaces(state: ExpectState = 'Warning') -&gt; Callable</code>","text":"<p>Returns a function that checks if table names in a Pbip object do not contain spaces.</p> <p>Parameters:</p> <ul> <li> <code>state</code>               (<code>ExpectState</code>, default:                   <code>'Warning'</code> )           \u2013            <p>The state of the expectation, defaults to 'Warning'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>A function that checks if table names in a Pbip object do not contain spaces.</p> </li> </ul> Source code in <code>pbipinspect/expectations.py</code> <pre><code>def expect_table_name_no_spaces(\n    state: ExpectState = 'Warning'\n) -&gt; Callable:\n    \"\"\"\n    Returns a function that checks if table names in a Pbip object do not contain spaces.\n\n    Parameters\n    ----------\n    state : ExpectState, optional\n        The state of the expectation, defaults to 'Warning'.\n\n    Returns\n    -------\n    Callable\n        A function that checks if table names in a Pbip object do not contain spaces.\n    \"\"\"\n\n    def function(pbip: Pbip) -&gt; list[ExpectMessage]:\n        tables = pbip.tables\n        checks = []\n        for table in tables:\n            table_name = table['name']\n            if ' ' in table_name:\n                checks.append({\n                    'expect': 'expect_table_name_no_spaces',\n                    'state': state,\n                    'message': f\"Table '{table_name}' must not contain spaces\",\n                })\n        return checks\n    return function\n</code></pre>"},{"location":"reference/expectations/#pbipinspect.expectations.expect_table_starts_with","title":"<code>expect_table_starts_with(pattern: str, state: ExpectState = 'Warning') -&gt; Callable</code>","text":"<p>Returns a function that checks if table names in a Pbip object start with the specified pattern.</p> <p>Parameters:</p> <ul> <li> <code>pattern</code>               (<code>str</code>)           \u2013            <p>The pattern to match against the table name.</p> </li> <li> <code>state</code>               (<code>ExpectState</code>, default:                   <code>'Warning'</code> )           \u2013            <p>The state of the expectation, defaults to 'Warning'.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>A function that checks if table names in a Pbip object start with the specified pattern.</p> </li> </ul> Source code in <code>pbipinspect/expectations.py</code> <pre><code>def expect_table_starts_with(\n    pattern: str, \n    state: ExpectState = 'Warning'\n) -&gt; Callable:\n    \"\"\"\n    Returns a function that checks if table names in a Pbip object start\n    with the specified pattern.\n\n    Parameters\n    ----------\n    pattern : str\n        The pattern to match against the table name.\n    state : ExpectState, optional\n        The state of the expectation, defaults to 'Warning'.\n\n    Returns\n    -------\n    Callable\n        A function that checks if table names in a Pbip object start\n        with the specified pattern.\n    \"\"\"\n    def function(pbip: Pbip) -&gt; list[ExpectMessage]:\n        tables = pbip.tables\n        checks = []\n        for table in tables:\n            table_name = table['name']\n            if not table_name.startswith(pattern):\n                checks.append({\n                    'expect': 'expect_table_starts_with',\n                    'state': state,\n                    'message': f\"Table '{table_name}' must start with '{pattern}'\",\n                })\n        return checks\n    return function\n</code></pre>"},{"location":"reference/inspect/","title":"inspect","text":"<p>Classes:</p> <ul> <li> <code>PbipInspect</code>           \u2013            <p>A class for inspecting .pbip files and their associated TMDL and TMSL models.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>create_inspect</code>             \u2013              <p>Create a PbipInspect object from a given path, which can be a .pbip file or a directory </p> </li> </ul>"},{"location":"reference/inspect/#pbipinspect.inspect.PbipInspect","title":"<code>PbipInspect(name: str | Path, semantic_folder: str | Path, report_folder: str | Path)</code>","text":"<p>A class for inspecting .pbip files and their associated TMDL and TMSL models.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | Path</code>)           \u2013            <p>The name of the .pbip file.</p> </li> <li> <code>semantic_folder</code>               (<code>str | Path</code>)           \u2013            <p>The path of the semantic model folder.</p> </li> <li> <code>report_folder</code>               (<code>str | Path</code>)           \u2013            <p>The path of the report folder.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>expectations</code>             \u2013              <p>Register a list of expectation functions to run against the model.</p> </li> <li> <code>parse_pbip</code>             \u2013              <p>Parse the PBIP model from the semantic folder.</p> </li> <li> <code>parse_tmdl</code>             \u2013              <p>Parse the TMDL model from the semantic folder.</p> </li> <li> <code>parse_tmdl_relationships</code>             \u2013              <p>Parse the relationships from the 'relationships.tmdl' file.</p> </li> <li> <code>parse_tmdl_tables</code>             \u2013              <p>Parse all .tmdl files in the 'definition/tables' folder.</p> </li> <li> <code>parse_tmsl</code>             \u2013              <p>Parse the TMSL model from the semantic folder.</p> </li> <li> <code>run_expectations</code>             \u2013              <p>Executes all registered expectation functions against the model.</p> </li> </ul> Source code in <code>pbipinspect/inspect.py</code> <pre><code>def __init__(\n    self, \n    name: str | Path,\n    semantic_folder: str | Path,\n    report_folder: str | Path\n) -&gt; None:\n    \"\"\"\n    Initialize the PbipInspect object with a given name, semantic folder and report folder.\n\n    Parameters\n    ----------\n    name : str | Path\n        The name of the .pbip file.\n    semantic_folder : str | Path\n        The path of the semantic model folder.\n    report_folder : str | Path\n        The path of the report folder.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    self.name = name\n    self.semantic_folder = semantic_folder\n    self.report_folder = report_folder\n    self._model = self.parse_pbip()\n    self.steps: list[Callable] = []\n    self.expects: list[ExpectMessage] = []\n</code></pre>"},{"location":"reference/inspect/#pbipinspect.inspect.PbipInspect.expectations","title":"<code>expectations(steps: list[Callable])</code>","text":"<p>Register a list of expectation functions to run against the model.</p> <p>Parameters:</p> <ul> <li> <code>steps</code>               (<code>list[Callable]</code>)           \u2013            <p>A list of functions that take a Pbip object as an argument and return a list of ExpectMessage.</p> </li> </ul> Source code in <code>pbipinspect/inspect.py</code> <pre><code>def expectations(self, steps: list[Callable]):\n    \"\"\"\n    Register a list of expectation functions to run against the model.\n\n    Parameters\n    ----------\n    steps : list[Callable]\n        A list of functions that take a Pbip object as an argument and return a list of ExpectMessage.\n    \"\"\"\n    self.steps = steps\n</code></pre>"},{"location":"reference/inspect/#pbipinspect.inspect.PbipInspect.parse_pbip","title":"<code>parse_pbip() -&gt; Pbip</code>","text":"<p>Parse the PBIP model from the semantic folder.</p> <p>Returns:</p> <ul> <li> <code>Pbip</code>           \u2013            <p>An object representing the parsed model, containing the model and a method to run expectations.</p> </li> </ul> Source code in <code>pbipinspect/inspect.py</code> <pre><code>def parse_pbip(self) -&gt; Pbip:\n    \"\"\"\n    Parse the PBIP model from the semantic folder.\n\n    Returns\n    -------\n    Pbip\n        An object representing the parsed model, containing the model and a method to run expectations.\n    \"\"\"\n    tmsl_check = is_TMSL(self.semantic_folder)\n    parse = self.parse_tmsl if tmsl_check else self.parse_tmdl\n    final_model = parse()\n    return Pbip(final_model)\n</code></pre>"},{"location":"reference/inspect/#pbipinspect.inspect.PbipInspect.parse_tmdl","title":"<code>parse_tmdl() -&gt; dict</code>","text":"<p>Parse the TMDL model from the semantic folder.</p> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>A dictionary representing the model, containing lists of tables and relationships.</p> </li> </ul> Source code in <code>pbipinspect/inspect.py</code> <pre><code>def parse_tmdl(self) -&gt; dict:\n    \"\"\"\n    Parse the TMDL model from the semantic folder.\n\n    Returns\n    -------\n    dict\n        A dictionary representing the model, containing lists of tables and relationships.\n    \"\"\"\n    final_model: dict = {\n        'model': {\n            'tables': [],\n            'relationships': []\n        }\n    }\n    final_model['model']['tables'] = self.parse_tmdl_tables()\n    final_model['model']['relationships'] = self.parse_tmdl_relationships()\n    return final_model\n</code></pre>"},{"location":"reference/inspect/#pbipinspect.inspect.PbipInspect.parse_tmdl_relationships","title":"<code>parse_tmdl_relationships() -&gt; list[dict] | None</code>","text":"<p>Parse the relationships from the 'relationships.tmdl' file.</p> <p>Returns:</p> <ul> <li> <code>list[dict] | None</code>           \u2013            <p>If the 'definition/tables' folder does not exist, return None. Otherwise, return a list of dictionaries with relationship details.</p> </li> </ul> Source code in <code>pbipinspect/inspect.py</code> <pre><code>def parse_tmdl_relationships(self) -&gt; list[dict] | None:\n    \"\"\"\n    Parse the relationships from the 'relationships.tmdl' file.\n\n    Returns\n    -------\n    list[dict] | None\n        If the 'definition/tables' folder does not exist, return None.\n        Otherwise, return a list of dictionaries with relationship details.\n    \"\"\"\n    folder = self.semantic_folder\n    check = has_table_folder(folder)\n    if not check:\n        return None\n    relationship = get_tmdl_relationship_file(folder)\n    content = relationship.read_text()\n    parsed_relationship = get_tmdl_relationship(content)\n    return parsed_relationship\n</code></pre>"},{"location":"reference/inspect/#pbipinspect.inspect.PbipInspect.parse_tmdl_tables","title":"<code>parse_tmdl_tables() -&gt; list[dict] | None</code>","text":"<p>Parse all .tmdl files in the 'definition/tables' folder.</p> <p>Returns:</p> <ul> <li> <code>list[dict] | None</code>           \u2013            <p>If the 'definition/tables' folder does not exists, return None. Otherwise, return a list of dictionaries, each one representing a table.</p> </li> </ul> Source code in <code>pbipinspect/inspect.py</code> <pre><code>def parse_tmdl_tables(self) -&gt; list[dict] | None:\n    \"\"\"\n    Parse all .tmdl files in the 'definition/tables' folder.\n\n    Returns\n    -------\n    list[dict] | None\n        If the 'definition/tables' folder does not exists, return None.\n        Otherwise, return a list of dictionaries, each one representing a table.\n    \"\"\"\n    folder = self.semantic_folder\n    check = has_table_folder(folder)\n    if not check:\n        return None\n    tables = get_tmdl_table_files(folder)\n    parsed_tables = []\n    for table in tables:\n        content = table.read_text()\n        tmdl_parsed = get_tmdl_table(content)\n        parsed_tables.append(tmdl_parsed)\n    return parsed_tables\n</code></pre>"},{"location":"reference/inspect/#pbipinspect.inspect.PbipInspect.parse_tmsl","title":"<code>parse_tmsl() -&gt; dict</code>","text":"<p>Parse the TMSL model from the semantic folder.</p> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>A dictionary representing the model, containing lists of tables and relationships.</p> </li> </ul> Source code in <code>pbipinspect/inspect.py</code> <pre><code>def parse_tmsl(self) -&gt; dict:\n    \"\"\"\n    Parse the TMSL model from the semantic folder.\n\n    Returns\n    -------\n    dict\n        A dictionary representing the model, containing lists of tables and relationships.\n    \"\"\"\n    model_bim = build_tmsl_path(self.semantic_folder)\n    with open(model_bim, 'r') as f:\n        tmsl = json.load(f)\n    final_model = clean_tmsl(tmsl)\n    return final_model\n</code></pre>"},{"location":"reference/inspect/#pbipinspect.inspect.PbipInspect.run_expectations","title":"<code>run_expectations()</code>","text":"<p>Executes all registered expectation functions against the model.</p> <p>The method iterates over the list of expectation functions stored in <code>self.steps</code>  and applies each function to the model. It collects the results, which are lists  of <code>ExpectMessage</code> dictionaries, and flattens them into a single list stored in  <code>self.expects</code>.</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul> Source code in <code>pbipinspect/inspect.py</code> <pre><code>def run_expectations(self):\n    \"\"\"\n    Executes all registered expectation functions against the model.\n\n    The method iterates over the list of expectation functions stored in `self.steps` \n    and applies each function to the model. It collects the results, which are lists \n    of `ExpectMessage` dictionaries, and flattens them into a single list stored in \n    `self.expects`.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    results = []\n    for expect in self.steps:\n        results.append(expect(self.model))\n    self.expects = [x for y in results for x in y]\n</code></pre>"},{"location":"reference/inspect/#pbipinspect.inspect.create_inspect","title":"<code>create_inspect(path: str | Path) -&gt; PbipInspect</code>","text":"<p>Create a PbipInspect object from a given path, which can be a .pbip file or a directory  containing .pbip files. Validates the presence and uniqueness of .pbip files, and verifies  the existence of required folders.</p> <p>Parameters:</p> <ul> <li> <code>path</code>               (<code>str | Path</code>)           \u2013            <p>The path to a specific .pbip file or a directory that may contain .pbip files.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PbipInspect</code>           \u2013            <p>An instance of PbipInspect initialized with the .pbip file's name, semantic folder,  and report folder.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>PbipNotFoundError</code>             \u2013            <p>If no .pbip file is found in the specified directory.</p> </li> <li> <code>MultiplePbipFilesError</code>             \u2013            <p>If more than one .pbip file is found in the specified directory.</p> </li> <li> <code>SemanticModelFolderNotFoundError</code>             \u2013            <p>If the semantic folder does not exist.</p> </li> </ul> Source code in <code>pbipinspect/inspect.py</code> <pre><code>def create_inspect(path: str | Path) -&gt; PbipInspect:\n    \"\"\"\n    Create a PbipInspect object from a given path, which can be a .pbip file or a directory \n    containing .pbip files. Validates the presence and uniqueness of .pbip files, and verifies \n    the existence of required folders.\n\n    Parameters\n    ----------\n    path : str | Path\n        The path to a specific .pbip file or a directory that may contain .pbip files.\n\n    Returns\n    -------\n    PbipInspect\n        An instance of PbipInspect initialized with the .pbip file's name, semantic folder, \n        and report folder.\n\n    Raises\n    ------\n    PbipNotFoundError\n        If no .pbip file is found in the specified directory.\n    MultiplePbipFilesError\n        If more than one .pbip file is found in the specified directory.\n    SemanticModelFolderNotFoundError\n        If the semantic folder does not exist.\n    \"\"\"\n    check_pbip = is_pbip_file(path)\n    pbips = [Path(path)] if check_pbip else find_pbip_file(path)\n\n    if not pbips:\n        raise PbipNotFoundError(path)\n\n    if len(pbips) &gt; 1:\n        raise MultiplePbipFilesError(path, pbips)\n\n    pbip = pbips[0]\n    pbip_name = get_pbip_name(pbip)\n    semantic_folder = get_semantic_model_path(pbip)\n\n    if not semantic_folder.is_dir():\n        raise SemanticModelFolderNotFoundError(semantic_folder)\n\n    report_folder = get_report_path(pbip)\n    inspect = PbipInspect(pbip_name, semantic_folder, report_folder)\n    return inspect\n</code></pre>"},{"location":"reference/pbip/","title":"pbip","text":"<p>Classes:</p> <ul> <li> <code>Pbip</code>           \u2013            <p>A class that represents pbip model.</p> </li> </ul>"},{"location":"reference/pbip/#pbipinspect.pbip.Pbip","title":"<code>Pbip(model: dict)</code>","text":"<p>A class that represents pbip model.</p> <p>Parameters:</p> <ul> <li> <code>model</code>               (<code>dict</code>)           \u2013            <p>The model dictionary containing the data structure.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>get_table_column</code>             \u2013              <p>Get a column of a table.</p> </li> <li> <code>get_table_field</code>             \u2013              <p>Get a field of a table.</p> </li> <li> <code>get_table_measure</code>             \u2013              <p>Retrieve a specific measure from a table.</p> </li> </ul> Source code in <code>pbipinspect/pbip.py</code> <pre><code>def __init__(self, model: dict) -&gt; None:\n    \"\"\"\n    Initialize the Pbip object with a given model.\n\n    Parameters\n    ----------\n    model : dict\n        The model dictionary containing the data structure.\n    \"\"\"\n    self._model = model\n</code></pre>"},{"location":"reference/pbip/#pbipinspect.pbip.Pbip.get_table_column","title":"<code>get_table_column(table: str, column: str) -&gt; dict | None</code>","text":"<p>Get a column of a table.</p> <p>Parameters:</p> <ul> <li> <code>table</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> <li> <code>column</code>               (<code>str</code>)           \u2013            <p>The name of the column.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict | None</code>           \u2013            <p>The column of the table, or None if the table or column does not exist.</p> </li> </ul> Source code in <code>pbipinspect/pbip.py</code> <pre><code>def get_table_column(self, table: str, column: str) -&gt; dict | None:\n    \"\"\"\n    Get a column of a table.\n\n    Parameters\n    ----------\n    table : str\n        The name of the table.\n    column : str\n        The name of the column.\n\n    Returns\n    -------\n    dict | None\n        The column of the table, or None if the table or column does not exist.\n    \"\"\"\n    if table not in [x['name'] for x in self.tables]:\n        return None\n    for t in self.tables:\n        column_names = [x['name'] for x in t['columns']]\n        if t['name'] == table and column in column_names:\n            return t['columns'][column_names.index(column)]\n    return None\n</code></pre>"},{"location":"reference/pbip/#pbipinspect.pbip.Pbip.get_table_field","title":"<code>get_table_field(table: str, field: str) -&gt; list | None</code>","text":"<p>Get a field of a table.</p> <p>Parameters:</p> <ul> <li> <code>table</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> <li> <code>field</code>               (<code>str</code>)           \u2013            <p>The name of the field.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list | None</code>           \u2013            <p>The field of the table, or None if the table or field does not exist.</p> </li> </ul> Source code in <code>pbipinspect/pbip.py</code> <pre><code>def get_table_field(self, table: str, field: str) -&gt; list | None:\n    \"\"\"\n    Get a field of a table.\n\n    Parameters\n    ----------\n    table : str\n        The name of the table.\n    field : str\n        The name of the field.\n\n    Returns\n    -------\n    list | None\n        The field of the table, or None if the table or field does not exist.\n    \"\"\"\n    if table not in [x['name'] for x in self.tables]:\n        return None\n    for t in self.tables:\n        if t['name'] == table and field in t:\n            return t[field]\n    return None\n</code></pre>"},{"location":"reference/pbip/#pbipinspect.pbip.Pbip.get_table_measure","title":"<code>get_table_measure(table: str, measure: str) -&gt; dict | None</code>","text":"<p>Retrieve a specific measure from a table.</p> <p>Parameters:</p> <ul> <li> <code>table</code>               (<code>str</code>)           \u2013            <p>The name of the table.</p> </li> <li> <code>measure</code>               (<code>str</code>)           \u2013            <p>The name of the measure.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict | None</code>           \u2013            <p>The measure from the table, or None if the table or measure does not exist.</p> </li> </ul> Source code in <code>pbipinspect/pbip.py</code> <pre><code>def get_table_measure(self, table: str, measure: str) -&gt; dict | None:\n    \"\"\"\n    Retrieve a specific measure from a table.\n\n    Parameters\n    ----------\n    table : str\n        The name of the table.\n    measure : str\n        The name of the measure.\n\n    Returns\n    -------\n    dict | None\n        The measure from the table, or None if the table or measure does not exist.\n    \"\"\"\n    if table not in [x['name'] for x in self.tables]:\n        return None\n    for t in self.tables:\n        measure_names = [x['name'] for x in t['measures']]\n        if t['name'] == table and measure in measure_names:\n            return t['measures'][measure_names.index(measure)]\n    return None\n</code></pre>"},{"location":"reference/tmdl/","title":"tmdl","text":"<p>Functions:</p> <ul> <li> <code>get_table_columns</code>             \u2013              <p>Parse columns from the given tmdl string.</p> </li> <li> <code>get_table_measures</code>             \u2013              <p>Parse measures from the given tmdl string.</p> </li> <li> <code>get_table_partitions</code>             \u2013              <p>Parse partitions from the given tmdl string.</p> </li> <li> <code>get_tmdl_relationship</code>             \u2013              <p>Parse the relationships from a given TMDL content.</p> </li> <li> <code>get_tmdl_table</code>             \u2013              <p>Reads a .tmdl file and returns a dictionary containing the table information</p> </li> </ul>"},{"location":"reference/tmdl/#pbipinspect.tmdl.get_table_columns","title":"<code>get_table_columns(tmdl: str) -&gt; list[dict]</code>","text":"<p>Parse columns from the given tmdl string.</p> <p>Parameters:</p> <ul> <li> <code>tmdl</code>               (<code>str</code>)           \u2013            <p>TMDL string</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[dict]</code>           \u2013            <p>A list of dictionaries containing column information. Each dictionary has the following keys: - name: str - expression: str - isHidden: bool - isNameInferred: bool - dataType: str | None - lineageTag: str | None - summarizeBy: str | None - sourceColumn: str | None - annotations: list[dict] | None - calculated: bool</p> </li> </ul> Source code in <code>pbipinspect/tmdl.py</code> <pre><code>def get_table_columns(tmdl: str) -&gt; list[dict]:\n    \"\"\"\n    Parse columns from the given tmdl string.\n\n    Parameters\n    ----------\n    tmdl : str\n        TMDL string\n\n    Returns\n    -------\n    list[dict]\n        A list of dictionaries containing column information. Each dictionary has the following keys:\n        - name: str\n        - expression: str\n        - isHidden: bool\n        - isNameInferred: bool\n        - dataType: str | None\n        - lineageTag: str | None\n        - summarizeBy: str | None\n        - sourceColumn: str | None\n        - annotations: list[dict] | None\n        - calculated: bool\n    \"\"\"\n    content = get_table_columns_content(tmdl)\n    columns = []\n    for x in content:\n        cur_value = re.split(r'measure|partition|hierarchy', x)[0]\n        name, expression = get_table_column_name_expression(cur_value)\n        data_type = get_table_column_data_type(cur_value)\n        is_hidden = 'isHidden' in cur_value\n        is_name_inferred = 'isNameInferred' in cur_value\n        lineage_tag = get_lineage_tag(cur_value)\n        summarize_by = get_table_summarize_by(cur_value)\n        source_column = get_table_source_column(cur_value)\n        annotations = get_annotations(cur_value)\n        columns.append({\n            'name': name,\n            'expression': expression,\n            'isHidden': is_hidden,\n            'isNameInferred': is_name_inferred,\n            'dataType': data_type,\n            'lineageTag': lineage_tag,\n            'summarizeBy': summarize_by,\n            'sourceColumn': source_column,\n            'annotations': annotations,\n            'calculated': str(source_column).startswith('[') or expression\n        })\n    return columns\n</code></pre>"},{"location":"reference/tmdl/#pbipinspect.tmdl.get_table_measures","title":"<code>get_table_measures(tmdl: str) -&gt; list[dict]</code>","text":"<p>Parse measures from the given tmdl string.</p> <p>Parameters:</p> <ul> <li> <code>tmdl</code>               (<code>str</code>)           \u2013            <p>TMDL string</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[dict]</code>           \u2013            <p>A list of dictionaries containing measure information. Each dictionary has the following keys: - name: str - formatString: str | None - annotations: list[str] - displayFolder: str | None - lineageTag: str | None - expression: str</p> </li> </ul> Source code in <code>pbipinspect/tmdl.py</code> <pre><code>def get_table_measures(tmdl: str) -&gt; list[dict]:\n    \"\"\"\n    Parse measures from the given tmdl string.\n\n    Parameters\n    ----------\n    tmdl : str\n        TMDL string\n\n    Returns\n    -------\n    list[dict]\n        A list of dictionaries containing measure information. Each dictionary has the following keys:\n        - name: str\n        - formatString: str | None\n        - annotations: list[str]\n        - displayFolder: str | None\n        - lineageTag: str | None\n        - expression: str\n    \"\"\"\n    splited = [x for x in tmdl.split('measure')[1:]]\n    measures = []\n    for x in splited:\n        cur_value = re.split(r'partition|column|hierarchy', x)[0]\n        name = get_table_measure_name(cur_value)\n        format_string = get_table_measure_format_string(cur_value)\n        display_folder = get_table_measure_display_folder(cur_value)\n        lineage_tag = get_lineage_tag(cur_value)\n        annotations = get_annotations(cur_value)\n        expression = get_table_measure_expression(cur_value)\n        measures.append({\n            'name': name,\n            'formatString': format_string,\n            'annotations': annotations,\n            'displayFolder': display_folder,\n            'lineageTag': lineage_tag,\n            'expression': expression\n        })\n    return measures\n</code></pre>"},{"location":"reference/tmdl/#pbipinspect.tmdl.get_table_partitions","title":"<code>get_table_partitions(tmdl: str) -&gt; list[dict]</code>","text":"<p>Parse partitions from the given tmdl string.</p> <p>Parameters:</p> <ul> <li> <code>tmdl</code>               (<code>str</code>)           \u2013            <p>TMDL string</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[dict]</code>           \u2013            <p>A list of dictionaries containing partition information. Each dictionary has the following keys: - name: str - type: str - mode: str - expression: str</p> </li> </ul> Source code in <code>pbipinspect/tmdl.py</code> <pre><code>def get_table_partitions(tmdl: str) -&gt; list[dict]:\n    \"\"\"\n    Parse partitions from the given tmdl string.\n\n    Parameters\n    ----------\n    tmdl : str\n        TMDL string\n\n    Returns\n    -------\n    list[dict]\n        A list of dictionaries containing partition information. Each dictionary has the following keys:\n        - name: str\n        - type: str\n        - mode: str\n        - expression: str\n    \"\"\"\n    splited = [x for x in tmdl.split('partition')[1:]]\n    partitions = []\n    for x in splited:\n        cur_value = re.split(r'measure|column|hierarchy|annotation', x)[0]\n        name, type = get_table_partition_name_type(cur_value)\n        mode = get_table_partition_mode(cur_value)\n        source = get_table_partition_source(cur_value)\n        partitions.append({\n            'name': name,\n            'type': type,\n            'mode': mode,\n            'expression': source\n        })\n    return partitions\n</code></pre>"},{"location":"reference/tmdl/#pbipinspect.tmdl.get_tmdl_relationship","title":"<code>get_tmdl_relationship(tmdl: str) -&gt; list[dict]</code>","text":"<p>Parse the relationships from a given TMDL content.</p> <p>Parameters:</p> <ul> <li> <code>tmdl</code>               (<code>str</code>)           \u2013            <p>The content of a TMDL file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[dict]</code>           \u2013            <p>A list of dictionaries, each one representing a relationship. Each dictionary has the following keys:     'name': str         The name of the relationship.     'fromTable': str         The name of the table from which the relationship starts.     'fromColumn': str         The name of the column from which the relationship starts.     'toTable': str         The name of the table to which the relationship ends.     'toColumn': str         The name of the column to which the relationship ends.     'crossFilteringBehavior': str         The cross filtering behavior of the relationship.         Can be 'oneDirection' or 'bothDirections'.     'toCardinality': str         The cardinality of the relationship.         Can be 'oneToOne', 'oneToMany' or 'manyToMany'.     'isActive': bool         Whether the relationship is active or not.</p> </li> </ul> Source code in <code>pbipinspect/tmdl.py</code> <pre><code>def get_tmdl_relationship(tmdl: str) -&gt; list[dict]:\n    \"\"\"\n    Parse the relationships from a given TMDL content.\n\n    Parameters\n    ----------\n    tmdl : str\n        The content of a TMDL file.\n\n    Returns\n    -------\n    list[dict]\n        A list of dictionaries, each one representing a relationship.\n        Each dictionary has the following keys:\n            'name': str\n                The name of the relationship.\n            'fromTable': str\n                The name of the table from which the relationship starts.\n            'fromColumn': str\n                The name of the column from which the relationship starts.\n            'toTable': str\n                The name of the table to which the relationship ends.\n            'toColumn': str\n                The name of the column to which the relationship ends.\n            'crossFilteringBehavior': str\n                The cross filtering behavior of the relationship.\n                Can be 'oneDirection' or 'bothDirections'.\n            'toCardinality': str\n                The cardinality of the relationship.\n                Can be 'oneToOne', 'oneToMany' or 'manyToMany'.\n            'isActive': bool\n                Whether the relationship is active or not.\n    \"\"\"\n\n    splited = tmdl.split('relationship')[1:]\n    relationships = []\n    for x in splited:\n        name = get_relationship_name(x)\n        from_table, from_column = get_relationship_from_column(x)\n        to_table, to_column = get_relationship_to_column(x)\n        cross_filtering_behavior = get_relationship_cross_filtering_behavior(x)\n        to_cardinality = get_relationship_cardinality(x)\n        is_active = get_relationship_is_active(x)\n        relationships.append({\n            'name': name,\n            'fromTable': from_table,\n            'fromColumn': from_column,\n            'toTable': to_table,\n            'toColumn': to_column,\n            'crossFilteringBehavior': cross_filtering_behavior,\n            'toCardinality': to_cardinality,\n            'isActive': is_active\n        })\n    return relationships\n</code></pre>"},{"location":"reference/tmdl/#pbipinspect.tmdl.get_tmdl_table","title":"<code>get_tmdl_table(tmdl: str) -&gt; dict</code>","text":"<p>Reads a .tmdl file and returns a dictionary containing the table information</p> <p>Parameters:</p> <ul> <li> <code>tmdl</code>               (<code>str</code>)           \u2013            <p>The contents of the .tmdl file</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>A dictionary containing the table information with the following keys:     - name: The name of the table     - lineageTag: The lineage tag of the table     - isHidden: A boolean indicating if the table is hidden     - isPrivate: A boolean indicating if the table is private     - columns: A list of dictionaries containing the column information     - measures: A list of dictionaries containing the measure information     - partitions: A list of dictionaries containing the partition information</p> </li> </ul> Source code in <code>pbipinspect/tmdl.py</code> <pre><code>def get_tmdl_table(tmdl: str) -&gt; dict:\n    \"\"\"\n    Reads a .tmdl file and returns a dictionary containing the table information\n\n    Parameters\n    ----------\n    tmdl : str\n        The contents of the .tmdl file\n\n    Returns\n    -------\n    dict\n        A dictionary containing the table information with the following keys:\n            - name: The name of the table\n            - lineageTag: The lineage tag of the table\n            - isHidden: A boolean indicating if the table is hidden\n            - isPrivate: A boolean indicating if the table is private\n            - columns: A list of dictionaries containing the column information\n            - measures: A list of dictionaries containing the measure information\n            - partitions: A list of dictionaries containing the partition information\n    \"\"\"\n    table_name = get_table_name(tmdl)\n    lineage_tag = get_table_lineage_tag(tmdl)\n    is_hidden = check_table_property(tmdl, 'isHidden')\n    is_private = check_table_property(tmdl, 'isPrivate')\n    table_columns = get_table_columns(tmdl)\n    table_measures = get_table_measures(tmdl)\n    table_partitions = get_table_partitions(tmdl)\n    return {\n        'name': table_name,\n        'lineageTag': lineage_tag,\n        'isHidden': is_hidden,\n        'isPrivate': is_private,\n        'columns': table_columns,\n        'measures': table_measures,\n        'partitions': table_partitions\n    }\n</code></pre>"},{"location":"reference/tmsl/","title":"tmsl","text":"<p>Functions:</p> <ul> <li> <code>clean_tmsl</code>             \u2013              <p>Clean the given TMSL model.</p> </li> <li> <code>clean_tmsl_columns</code>             \u2013              <p>Clean columns from the given TMSL model.</p> </li> <li> <code>clean_tmsl_measures</code>             \u2013              <p>Clean measures from the given TMSL model.</p> </li> <li> <code>clean_tmsl_partitions</code>             \u2013              <p>Clean the given list of partition dictionaries.</p> </li> <li> <code>clean_tmsl_relationships</code>             \u2013              <p>Clean relationships from the given TMSL model.</p> </li> <li> <code>clean_tmsl_tables</code>             \u2013              <p>Clean tables from the given TMSL model.</p> </li> </ul>"},{"location":"reference/tmsl/#pbipinspect.tmsl.clean_tmsl","title":"<code>clean_tmsl(tmsl_model: dict) -&gt; dict</code>","text":"<p>Clean the given TMSL model.</p> <p>Parameters:</p> <ul> <li> <code>tmsl_model</code>               (<code>dict</code>)           \u2013            <p>The TMSL model to clean.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>A cleaned version of the given TMSL model.</p> </li> </ul> Source code in <code>pbipinspect/tmsl.py</code> <pre><code>def clean_tmsl(tmsl_model: dict) -&gt; dict:\n    \"\"\"\n    Clean the given TMSL model.\n\n    Parameters\n    ----------\n    tmsl_model : dict\n        The TMSL model to clean.\n\n    Returns\n    -------\n    dict\n        A cleaned version of the given TMSL model.\n    \"\"\"\n    model = tmsl_model['model']\n    tables = model['tables']\n    relationships = model['relationships']\n    cleaned_tables = clean_tmsl_tables(tables)\n    cleaned_relationships = clean_tmsl_relationships(relationships)\n    new_model = {\n        'model': {\n            'tables': cleaned_tables,\n            'relationships': cleaned_relationships\n        }\n    }\n    return new_model\n</code></pre>"},{"location":"reference/tmsl/#pbipinspect.tmsl.clean_tmsl_columns","title":"<code>clean_tmsl_columns(columns: list[dict]) -&gt; list[dict]</code>","text":"<p>Clean columns from the given TMSL model.</p> <p>Parameters:</p> <ul> <li> <code>columns</code>               (<code>list[dict]</code>)           \u2013            <p>The list of columns to clean</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[dict]</code>           \u2013            <p>A list of cleaned column dictionaries. The dictionaries have the following keys: - name: str - expression: str | None - isHidden: bool - isNameInferred: bool - dataType: str - lineageTag: str - summarizeBy: str - sourceColumn: str | None - annotations: list[str] | None - calculated: bool</p> </li> </ul> Source code in <code>pbipinspect/tmsl.py</code> <pre><code>def clean_tmsl_columns(columns: list[dict]) -&gt; list[dict]:\n    \"\"\"\n    Clean columns from the given TMSL model.\n\n    Parameters\n    ----------\n    columns : list[dict]\n        The list of columns to clean\n\n    Returns\n    -------\n    list[dict]\n        A list of cleaned column dictionaries. The dictionaries have the following keys:\n        - name: str\n        - expression: str | None\n        - isHidden: bool\n        - isNameInferred: bool\n        - dataType: str\n        - lineageTag: str\n        - summarizeBy: str\n        - sourceColumn: str | None\n        - annotations: list[str] | None\n        - calculated: bool\n    \"\"\"\n    cleaned: list[dict] = []\n    if not columns:\n        return cleaned\n    for column in columns:\n        cleaned.append({\n            'name': column['name'],\n            'expression': column.get('expression', ''),\n            'isHidden': column.get('isHidden', False),\n            'isNameInferred': column.get('isHidden', False),\n            'dataType': column['dataType'],\n            'lineageTag': column['lineageTag'],\n            'summarizeBy': column['summarizeBy'],\n            'sourceColumn': column.get('sourceColumn'),\n            'annotations': column.get('annotations'),\n            'calculated': str(column.get('sourceColumn')).startswith('[') or bool(column.get('expression'))\n        })\n    return cleaned\n</code></pre>"},{"location":"reference/tmsl/#pbipinspect.tmsl.clean_tmsl_measures","title":"<code>clean_tmsl_measures(measures: list[dict]) -&gt; list[dict]</code>","text":"<p>Clean measures from the given TMSL model.</p> <p>Parameters:</p> <ul> <li> <code>measures</code>               (<code>list[dict]</code>)           \u2013            <p>The list of measures to clean.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[dict]</code>           \u2013            <p>A list of cleaned measure dictionaries. Each dictionary contains the following keys: - name: str - lineageTag: str - annotations: list[str] | None - displayFolder: str - expression: str - formatString: str | None</p> </li> </ul> Source code in <code>pbipinspect/tmsl.py</code> <pre><code>def clean_tmsl_measures(measures: list[dict]) -&gt; list[dict]:\n    \"\"\"\n    Clean measures from the given TMSL model.\n\n    Parameters\n    ----------\n    measures : list[dict]\n        The list of measures to clean.\n\n    Returns\n    -------\n    list[dict]\n        A list of cleaned measure dictionaries. Each dictionary contains the following keys:\n        - name: str\n        - lineageTag: str\n        - annotations: list[str] | None\n        - displayFolder: str\n        - expression: str\n        - formatString: str | None\n    \"\"\"\n    cleaned: list[dict] = []\n    if not measures:\n        return cleaned\n    for measure in measures:\n        cleaned.append({\n            'name': measure['name'],\n            'lineageTag': measure['lineageTag'],\n            'annotations': measure.get('annotations'),\n            'displayFolder': measure['displayFolder'],\n            'expression': ''.join(measure['expression']),\n            'formatString': measure.get('formatString')\n        })\n    return cleaned\n</code></pre>"},{"location":"reference/tmsl/#pbipinspect.tmsl.clean_tmsl_partitions","title":"<code>clean_tmsl_partitions(partitions: list[dict]) -&gt; list[dict]</code>","text":"<p>Clean the given list of partition dictionaries.</p> <p>Parameters:</p> <ul> <li> <code>partitions</code>               (<code>list[dict]</code>)           \u2013            <p>The list of partition dictionaries to clean</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[dict]</code>           \u2013            <p>A list of cleaned partition dictionaries. The dictionaries have the following keys: - name: str - type: str - mode: str - expression: str</p> </li> </ul> Source code in <code>pbipinspect/tmsl.py</code> <pre><code>def clean_tmsl_partitions(partitions: list[dict]) -&gt; list[dict]:\n    \"\"\"\n    Clean the given list of partition dictionaries.\n\n    Parameters\n    ----------\n    partitions : list[dict]\n        The list of partition dictionaries to clean\n\n    Returns\n    -------\n    list[dict]\n        A list of cleaned partition dictionaries. The dictionaries have the following keys:\n        - name: str\n        - type: str\n        - mode: str\n        - expression: str\n    \"\"\"\n    cleaned = []\n    for partition in partitions:\n        cleaned.append({\n            'name': partition['name'],\n            'type': partition['source']['type'],\n            'mode': partition['mode'],\n            'expression': ''.join(partition['source']['expression'])\n        })\n    return cleaned\n</code></pre>"},{"location":"reference/tmsl/#pbipinspect.tmsl.clean_tmsl_relationships","title":"<code>clean_tmsl_relationships(relationships: list[dict]) -&gt; list[dict]</code>","text":"<p>Clean relationships from the given TMSL model.</p> <p>Parameters:</p> <ul> <li> <code>relationships</code>               (<code>list[dict]</code>)           \u2013            <p>The list of relationships to clean.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[dict]</code>           \u2013            <p>A list of cleaned relationship dictionaries. Each dictionary contains the following keys: - name: str - fromTable: str - fromColumn: str - toTable: str - toColumn: str - crossFilteringBehavior: str - toCardinality: str - isActive: bool</p> </li> </ul> Source code in <code>pbipinspect/tmsl.py</code> <pre><code>def clean_tmsl_relationships(relationships: list[dict]) -&gt; list[dict]:\n    \"\"\"\n    Clean relationships from the given TMSL model.\n\n    Parameters\n    ----------\n    relationships : list[dict]\n        The list of relationships to clean.\n\n    Returns\n    -------\n    list[dict]\n        A list of cleaned relationship dictionaries. Each dictionary contains the following keys:\n        - name: str\n        - fromTable: str\n        - fromColumn: str\n        - toTable: str\n        - toColumn: str\n        - crossFilteringBehavior: str\n        - toCardinality: str\n        - isActive: bool\n    \"\"\"\n    cleaned = []\n    for relationship in relationships:\n        cleaned.append({\n            'name': relationship['name'],\n            'fromTable': relationship['fromTable'],\n            'fromColumn': relationship['fromColumn'],\n            'toTable': relationship['toTable'],\n            'toColumn': relationship['toColumn'],\n            'crossFilteringBehavior': relationship.get('crossFilteringBehavior', 'singleDirection'),\n            'toCardinality': relationship.get('toCardinality', 'oneToMany'),\n            'isActive': relationship.get('isActive', True)\n        })\n    return cleaned\n</code></pre>"},{"location":"reference/tmsl/#pbipinspect.tmsl.clean_tmsl_tables","title":"<code>clean_tmsl_tables(tables: list[dict]) -&gt; list[dict]</code>","text":"<p>Clean tables from the given TMSL model.</p> <p>Parameters:</p> <ul> <li> <code>tables</code>               (<code>list[dict]</code>)           \u2013            <p>The list of tables to clean.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[dict]</code>           \u2013            <p>A list of cleaned table dictionaries. Each dictionary contains the following keys: - name: str - lineageTag: str - isHidden: bool - isPrivate: bool - columns: list[dict] - measures: list[dict] - partitions: list[dict]</p> </li> </ul> Source code in <code>pbipinspect/tmsl.py</code> <pre><code>def clean_tmsl_tables(tables: list[dict]) -&gt; list[dict]:\n    \"\"\"\n    Clean tables from the given TMSL model.\n\n    Parameters\n    ----------\n    tables : list[dict]\n        The list of tables to clean.\n\n    Returns\n    -------\n    list[dict]\n        A list of cleaned table dictionaries. Each dictionary contains the following keys:\n        - name: str\n        - lineageTag: str\n        - isHidden: bool\n        - isPrivate: bool\n        - columns: list[dict]\n        - measures: list[dict]\n        - partitions: list[dict]\n    \"\"\"\n    cleaned = []\n    for table in tables:\n        cleaned.append({\n            'name': table['name'],\n            'lineageTag': table['lineageTag'],\n            'isHidden': table.get('isHidden', False),\n            'isPrivate': table.get('isPrivate', False),\n            'columns': clean_tmsl_columns(table.get('columns', [])),\n            'measures': clean_tmsl_measures(table.get('measures', [])),\n            'partitions': clean_tmsl_partitions(table['partitions'])\n        })\n    return cleaned\n</code></pre>"}]}